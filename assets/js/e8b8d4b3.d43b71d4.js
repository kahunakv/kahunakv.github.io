"use strict";(self.webpackChunkkahunakv_docs=self.webpackChunkkahunakv_docs||[]).push([[4395],{8052:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"distributed-locks/leases","title":"Leases","description":"Distributed locks in Kahuna are based on the paper [*\\"Leases: An Efficient","source":"@site/docs/distributed-locks/leases.md","sourceDirName":"distributed-locks","slug":"/distributed-locks/leases","permalink":"/docs/distributed-locks/leases","draft":false,"unlisted":false,"editUrl":"https://github.com/kahunakv/kahunakv.github.io/tree/main/docs/docs/distributed-locks/leases.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Distributed Locks","permalink":"/docs/distributed-locks"},"next":{"title":"Fencing Tokens","permalink":"/docs/distributed-locks/fencing-tokens"}}');var i=t(4848),a=t(8453);const r={},l="Leases",o={},c=[];function d(e){const s={a:"a",em:"em",h1:"h1",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"leases",children:"Leases"})}),"\n",(0,i.jsxs)(s.p,{children:["Distributed locks in Kahuna are based on the paper ",(0,i.jsx)(s.a,{href:"https://web.stanford.edu/class/cs240/readings/leases.pdf",children:(0,i.jsx)(s.em,{children:'"Leases: An Efficient\nFault-Tolerant Mechanism for Distributed File Cache Consistency"'})})," by Michael N. Nelson, Brent B. Welch, and John K. Ousterhout. It introduced the concept of ",(0,i.jsx)(s.strong,{children:"leases"})," as a way to manage distributed locks efficiently. Leases act as time-bound locks that expire after a specified duration, providing a balance between strong consistency and fault tolerance."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Automatic Lock Expiration"}),": Leases expire after a predefined time,\neliminating the need for manual lock release. This is particularly useful if a client holding a lock crashes or becomes unreachable, as the system can reclaim the resource once the lease expires."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"No Need for Explicit Unlock"}),": Despite Kahuna clients sent explicit unlocks, clients\ndon't need to explicitly release them, which reduces the complexity of\nhandling failures and network partitions."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Reduced Lock Contention"}),": Since leases are time-bound, even if a client misbehaves or gets disconnected, other clients will eventually be able to acquire the lock after the lease expires."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Graceful Degradation"}),": In the event of partial failures (e.g., network partitions), the system can still make progress once the lease times out."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Do leases provide mutual exclusion? No, leases by themselves do not provide mutual exclusion."}),"\n",(0,i.jsx)(s.p,{children:"While Kahuna leases help in expiring keys and releasing locks if a client fails, they don\u2019t inherently protect against scenarios where:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"A client pauses (e.g., due to a long GC pause or network partition) and later resumes, believing it still holds the lock, even though the lease has expired."}),"\n",(0,i.jsx)(s.li,{children:"This could lead to split-brain where two clients believe they own the same lock."}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>r,x:()=>l});var n=t(6540);const i={},a=n.createContext(i);function r(e){const s=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(a.Provider,{value:s},e.children)}}}]);