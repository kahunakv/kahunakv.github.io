"use strict";(self.webpackChunkkahunakv_docs=self.webpackChunkkahunakv_docs||[]).push([[8298],{6726:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"scripts/commands/extend","title":"Command: Extends","description":"Allows to extend a key/value expiration for persistent keys:","source":"@site/docs/scripts/commands/extend.md","sourceDirName":"scripts/commands","slug":"/scripts/commands/extend","permalink":"/docs/scripts/commands/extend","draft":false,"unlisted":false,"editUrl":"https://github.com/kahunakv/kahunakv.github.io/tree/main/docs/scripts/commands/extend.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Command: EGet","permalink":"/docs/scripts/commands/eget"},"next":{"title":"Command: Eextends","permalink":"/docs/scripts/commands/eextend"}}');var i=t(4848),r=t(8453);const a={},o="Command: Extends",c={},d=[{value:"Notes",id:"notes",level:2}];function l(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"command-extends",children:"Command: Extends"})}),"\n",(0,i.jsx)(s.p,{children:"Allows to extend a key/value expiration for persistent keys:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-swift",children:'set `services/email/instance-3` \'{"ip": "10.1.1.22", "port": 9090}\'\nr0 set 9ms\n\nextend `services/email/instance-3` 10000\nr0 set 7ms\n'})}),"\n",(0,i.jsx)(s.p,{children:"In the previous example, the key is set to expire in 10,000 ms (10 seconds) from the moment the extend command is executed."}),"\n",(0,i.jsx)(s.p,{children:"An expiration value of zero means that the key never expires:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-swift",children:"extend `services/email/instance-3` 0\nr0 set 7ms\n"})}),"\n",(0,i.jsx)(s.p,{children:"This is useful for keys that represent long-lived or permanent data, such as configuration settings, user profiles, or static resources that should remain available indefinitely unless explicitly deleted."}),"\n",(0,i.jsx)(s.h2,{id:"notes",children:"Notes"}),"\n",(0,i.jsxs)(s.p,{children:["For keys with short expiration times, it is recommended to use ",(0,i.jsx)(s.a,{href:"/docs/architecture/durability-levels",children:"ephemeral durability"})," whenever possible. This reduces disk I/O and replication overhead, making it more efficient for temporary data like session tokens, short-lived locks, or transient state."]}),"\n",(0,i.jsxs)(s.p,{children:["Internally, expiration timestamps are managed using the ",(0,i.jsx)(s.a,{href:"/docs/architecture/hybrid-logical-clocks",children:"Hybrid Logical Clock (HLC)"}),", which helps avoid issues caused by clock drift between nodes. This ensures that expiration times are consistent and causally ordered across the cluster, even in distributed environments where system clocks may differ slightly."]})]})}function m(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>o});var n=t(6540);const i={},r=n.createContext(i);function a(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);