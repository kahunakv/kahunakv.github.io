"use strict";(self.webpackChunkkahunakv_docs=self.webpackChunkkahunakv_docs||[]).push([[6104],{4075:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});var i=t(9036),s=t(4848),r=t(8453);const a={slug:"welcome",title:"Why I Built Kahuna - A New Take on Distributed Key/Value Storage",authors:["andresgutierrez"],tags:["kahuna"]},o="Why I Built Kahuna: A New Take on Distributed Key/Value Storage",l={authorsImageUrls:[void 0]},d=[{value:"Why the Name?",id:"why-the-name",level:2},{value:"Why .NET? Breaking the Language Paradigm",id:"why-net-breaking-the-language-paradigm",level:2},{value:"The Three Pillars of Kahuna",id:"the-three-pillars-of-kahuna",level:2},{value:"Why Kahuna?",id:"why-kahuna",level:2},{value:"<strong>Distributed Transactions with Snapshot Isolation or Serializable Consistency</strong>",id:"distributed-transactions-with-snapshot-isolation-or-serializable-consistency",level:3},{value:"<strong>Two Durability Modes: Persistent &amp; Ephemeral</strong>",id:"two-durability-modes-persistent--ephemeral",level:3},{value:"<strong>A More Powerful Approach to Distributed Locking</strong>",id:"a-more-powerful-approach-to-distributed-locking",level:3},{value:"<strong>Scripting Language Integration</strong>",id:"scripting-language-integration",level:2},{value:"<strong>Strong Consistency with Raft-Based Consensus</strong>",id:"strong-consistency-with-raft-based-consensus",level:3},{value:"<strong>Scalability Through Dynamic Partitioning</strong>",id:"scalability-through-dynamic-partitioning",level:3},{value:"Kahuna: A Unified Solution for Modern Distributed Applications",id:"kahuna-a-unified-solution-for-modern-distributed-applications",level:2}];function c(e){const n={a:"a",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["About eight years ago, I had the opportunity to build systems for my company using ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://www.erlang.org/",children:"Erlang"})}),". Discovering the actor model was a turning point in how I designed systems from that moment on. However, for strategic reasons, we had to move away from Erlang and focus on the .NET ecosystem. While robust and well-established actor model libraries for C# exist, they included many features we didn\u2019t need, and their performance wasn\u2019t entirely satisfactory for our use cases.\nThis led me to the idea of building a lightweight library."]}),"\n",(0,s.jsxs)(n.p,{children:["The goal of creating a simple library led me to develop ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://github.com/andresgutierrez/nixie",children:"Nixie"})}),". By leveraging ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/standard/collections/thread-safe/",children:"lock-free structures"})}),", strongly typed actors, low-level programming, and the ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl",children:"Task Processing Library (TPL)"})}),", I built a powerful foundation for application development. It immediately delivered the results we expected: fewer errors and higher performance."]}),"\n",(0,s.jsx)(n.p,{children:"Later, the need arose to develop a leader election library for one of our critical systems, one that wouldn\u2019t rely on an external system, would offer fault tolerance (electing a new leader if the current one failed or went down), and could be integrated into our .NET projects. It was also essential to support multiple partitions (sometimes called regions, groups, or tablets) to effectively utilize computing power without sacrificing consistency. The learning experience and hands-on work with Raft led me to open-source Kommander."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://github.com/andresgutierrez/kommander",children:"Kommander"})})," is a distributed consensus library for C#/.NET based on ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://raft.github.io/",children:"Raft"})}),". It supports multiple Raft groups, each with its own leader, followers, and replication log. It enables node communication via ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://grpc.io/",children:"gRPC"})})," (by default) or ",(0,s.jsx)(n.strong,{children:"REST/JSON"})," (for those who want or need to use any HTTP protocol 1.1/2/3 or require easy debugging). For the persistent write-ahead log (storage), it leverages the robust and battle-tested ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://rocksdb.org/",children:"RocksDB"})})," (created by Meta) as an embedded database, with ",(0,s.jsx)(n.strong,{children:"SQLite"})," also available as an option."]}),"\n",(0,s.jsx)(n.p,{children:"Kommander is built on Nixie, meaning processes like leader election, replication, compaction, and membership changes are handled using lightweight actors (state machines) and asynchronous communication. This approach enables hundreds or even thousands of partitions (groups), leveraging multi-core servers efficiently. Additionally, the actor model helps avoid multithreading concurrency issues, reducing the risk of hard-to-reproduce errors and lock contention."}),"\n",(0,s.jsx)(n.p,{children:"With Kommander and Nixie providing a solid foundation, I recognized additional needs that could be addressed with a new tool based on this technology. This led to the idea of building an auxiliary tool to centralize distributed concerns such as locks, leader election, configuration management, sessions, caching, sequencing, and more."}),"\n",(0,s.jsx)(n.p,{children:"In the past, we relied on various tools like Redis, Zookeeper, and even database tables to solve these challenges. However, it was easy to misuse a tool or assume it provided guarantees or performance levels that it actually didn\u2019t."}),"\n",(0,s.jsx)(n.p,{children:"Taking all of this into account, I created Kahuna."}),"\n",(0,s.jsx)(n.h2,{id:"why-the-name",children:"Why the Name?"}),"\n",(0,s.jsx)(n.p,{children:'The name "Kahuna" comes from a Hawaiian word traditionally used to describe an expert in a field\u2014a fitting metaphor for a tool that aims to be the expert all services consult for coordination and operation. Inspired by battle-tested systems like Redis, etcd, Zookeeper, and Google Spanner, Kahuna is more than just another key/value store.'}),"\n",(0,s.jsx)(n.h2,{id:"why-net-breaking-the-language-paradigm",children:"Why .NET? Breaking the Language Paradigm"}),"\n",(0,s.jsx)(n.p,{children:"One of my primary motivations for building Kahuna was to demonstrate that powerful, low-level systems infrastructure isn\u2019t limited to C++, Rust, Java, or Go. By implementing Kahuna in modern C# and .NET technologies, I wanted to challenge the prevailing notion that high-performance distributed systems can only be built with traditional systems programming languages. This isn\u2019t a hard rule\u2014there are great tools like Garnet, recently led by Microsoft. Similarly, in Java (a language with a garbage collector), you can find powerful distributed systems like Kafka, Cassandra, and Spark. This choice reflects not just a technical preference but a broader vision of expanding the distributed systems development ecosystem."}),"\n",(0,s.jsx)(n.h2,{id:"the-three-pillars-of-kahuna",children:"The Three Pillars of Kahuna"}),"\n",(0,s.jsx)(n.p,{children:"Kahuna brings together three critical distributed system primitives in one platform:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"A Distributed Key/Value Store"})," \u2013 for metadata storage, configuration, caching, sessions, and more."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"A Distributed Locking System"})," \u2013 for coordinating access to shared resources in a cluster."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"A Distributed Sequencer"})," \u2013 for generating globally ordered events, crucial for ensuring consistency in distributed workflows."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Many systems provide these functionalities separately, but I wanted ",(0,s.jsx)(n.strong,{children:"a single, unified solution"})," that integrates all three while maintaining strong consistency, high availability, simplicity, and efficient scalability."]}),"\n",(0,s.jsx)(n.h2,{id:"why-kahuna",children:"Why Kahuna?"}),"\n",(0,s.jsx)(n.h3,{id:"distributed-transactions-with-snapshot-isolation-or-serializable-consistency",children:(0,s.jsx)(n.strong,{children:"Distributed Transactions with Snapshot Isolation or Serializable Consistency"})}),"\n",(0,s.jsxs)(n.p,{children:["Kahuna supports multi-node ",(0,s.jsx)(n.strong,{children:"distributed transactions"})," with ",(0,s.jsx)(n.strong,{children:"optimistic or pessimistic locking"}),", allowing developers to balance performance and strict consistency. Transactions can achieve either:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Snapshot Isolation"})," (MVCC-based) for high-performance reads without conflicts."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Serializable Consistency"})," for the strongest level of isolation."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This makes Kahuna ideal for applications requiring strict data integrity guarantees in highly concurrent environments."}),"\n",(0,s.jsx)(n.h3,{id:"two-durability-modes-persistent--ephemeral",children:(0,s.jsx)(n.strong,{children:"Two Durability Modes: Persistent & Ephemeral"})}),"\n",(0,s.jsxs)(n.p,{children:["Not all data needs permanent storage. Kahuna supports ",(0,s.jsx)(n.strong,{children:"two durability modes"})," to optimize storage and performance:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Persistent Mode"}),": Data is replicated across nodes for ",(0,s.jsx)(n.strong,{children:"durability and fault tolerance"}),", ensuring high availability even during failures."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Ephemeral Mode"}),": Designed for ",(0,s.jsx)(n.strong,{children:"short-lived objects"})," such as ",(0,s.jsx)(n.strong,{children:"caching, short sessions, and temporary leases/locks"}),", ensuring lightweight storage without unnecessary replication overhead."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This flexibility allows developers to use Kahuna for both ",(0,s.jsx)(n.strong,{children:"long-term state storage and temporary coordination needs."})]}),"\n",(0,s.jsx)(n.h3,{id:"a-more-powerful-approach-to-distributed-locking",children:(0,s.jsx)(n.strong,{children:"A More Powerful Approach to Distributed Locking"})}),"\n",(0,s.jsxs)(n.p,{children:["Distributed locking is ",(0,s.jsx)(n.strong,{children:"notoriously difficult"})," to get right, and perfect distributed locks are nearly impossible. Kahuna provides ",(0,s.jsx)(n.strong,{children:"tools to help developers mitigate edge cases"}),", including:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Persisted Lock State"}),": Ensuring another node can maintain the lock state if the leader fails."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Leases with Expiration"}),": Preventing locks from persisting indefinitely if the holder crashes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fencing Tokens"}),": Preventing stale lock holders from causing race conditions."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["These mechanisms ",(0,s.jsx)(n.strong,{children:"greatly reduce"})," the risk of deadlocks, split-brain scenarios, and other failure conditions common in distributed environments."]}),"\n",(0,s.jsx)(n.h2,{id:"scripting-language-integration",children:(0,s.jsx)(n.strong,{children:"Scripting Language Integration"})}),"\n",(0,s.jsx)(n.p,{children:"A unique feature of Kahuna is its built-in scripting language, allowing developers to create consistent, transactional code that interacts directly with the key/value store."}),"\n",(0,s.jsx)(n.h3,{id:"strong-consistency-with-raft-based-consensus",children:(0,s.jsx)(n.strong,{children:"Strong Consistency with Raft-Based Consensus"})}),"\n",(0,s.jsxs)(n.p,{children:["Kahuna ensures ",(0,s.jsx)(n.strong,{children:"strong consistency"})," using the ",(0,s.jsx)(n.strong,{children:"Raft consensus algorithm"}),", with each partition managed by its own ",(0,s.jsx)(n.strong,{children:"Raft group"}),". This design provides:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fault tolerance"}),": Automatic leader election and replication ensure high availability."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consistency guarantees"}),": Every write is ",(0,s.jsx)(n.strong,{children:"strongly consistent"})," across multiple replicas."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"scalability-through-dynamic-partitioning",children:(0,s.jsx)(n.strong,{children:"Scalability Through Dynamic Partitioning"})}),"\n",(0,s.jsxs)(n.p,{children:["Kahuna is ",(0,s.jsx)(n.strong,{children:"horizontally scalable"}),", meaning it expands with infrastructure growth. It supports:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dynamic partitioning"})," (similar to sharding), allowing for ",(0,s.jsx)(n.strong,{children:"load balancing across nodes"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic rebalancing"}),", ensuring even workload distribution."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"kahuna-a-unified-solution-for-modern-distributed-applications",children:"Kahuna: A Unified Solution for Modern Distributed Applications"}),"\n",(0,s.jsxs)(n.p,{children:["Kahuna provides a ",(0,s.jsx)(n.strong,{children:"powerful yet flexible"})," foundation for building ",(0,s.jsx)(n.strong,{children:"reliable, scalable, and highly available"})," distributed applications. By integrating ",(0,s.jsx)(n.strong,{children:"storage, coordination, and sequencing"})," into one system, it reduces complexity and offers developers a ",(0,s.jsx)(n.strong,{children:"consistent, battle-tested approach to managing distributed workloads."})]}),"\n",(0,s.jsxs)(n.p,{children:["Kahuna is now ",(0,s.jsx)(n.strong,{children:"open-source"}),", and I\u2019d love to hear your thoughts! Whether you need a ",(0,s.jsx)(n.strong,{children:"transactional key/value store, a robust distributed lock system, or a global event sequencer"}),", ",(0,s.jsx)(n.strong,{children:"Kahuna is built to handle it all."})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}},9036:e=>{e.exports=JSON.parse('{"permalink":"/blog/welcome","editUrl":"https://github.com/kahunakv.github.io/tree/tree/main/docs/blog/2025-03-25-welcome/index.md","source":"@site/blog/2025-03-25-welcome/index.md","title":"Why I Built Kahuna - A New Take on Distributed Key/Value Storage","description":"About eight years ago, I had the opportunity to build systems for my company using Erlang. Discovering the actor model was a turning point in how I designed systems from that moment on. However, for strategic reasons, we had to move away from Erlang and focus on the .NET ecosystem. While robust and well-established actor model libraries for C# exist, they included many features we didn\u2019t need, and their performance wasn\u2019t entirely satisfactory for our use cases.","date":"2025-03-25T00:00:00.000Z","tags":[{"inline":true,"label":"kahuna","permalink":"/blog/tags/kahuna"}],"readingTime":5.73,"hasTruncateMarker":false,"authors":[{"name":"Andres Gutierrez","title":"Maintainer of Kahuna","url":"https://github.com/andresgutierrez","imageURL":"https://github.com/andresgutierrez.png","key":"andresgutierrez","page":null}],"frontMatter":{"slug":"welcome","title":"Why I Built Kahuna - A New Take on Distributed Key/Value Storage","authors":["andresgutierrez"],"tags":["kahuna"]},"unlisted":false}')}}]);