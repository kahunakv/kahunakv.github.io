"use strict";(self.webpackChunkkahunakv_docs=self.webpackChunkkahunakv_docs||[]).push([[9789],{2219:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"dotnet-client","title":"Client for .NET","description":"Kahuna also provides a client tailored for .NET developers. This client simplifies the integration of distributed locking into your .NET applications by abstracting much of the underlying complexity. Documentation and samples for the client can be found in the docs/ folder or on our GitHub repository.","source":"@site/docs/dotnet-client.md","sourceDirName":".","slug":"/dotnet-client","permalink":"/docs/dotnet-client","draft":false,"unlisted":false,"editUrl":"https://github.com/kahunakv/kahunakv.github.io/tree/main/docs/dotnet-client.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Kahuna CLI","permalink":"/docs/kahuna-cli"},"next":{"title":"Architecture Overview","permalink":"/docs/architecture/overview"}}');var t=a(4848),o=a(8453);const l={},c="Client for .NET",s={},r=[{value:"Client Installation",id:"client-installation",level:2},{value:"Locks: Usage &amp; Examples",id:"locks-usage--examples",level:2},{value:"Single attempt to acquire a lock",id:"single-attempt-to-acquire-a-lock",level:3},{value:"Multiple attempts to acquire a lock",id:"multiple-attempts-to-acquire-a-lock",level:3},{value:"Fencing Tokens",id:"fencing-tokens",level:3},{value:"Periodically extend a lock",id:"periodically-extend-a-lock",level:3},{value:"Retrieve information about a lock",id:"retrieve-information-about-a-lock",level:3},{value:"Configure a pool of endpoints",id:"configure-a-pool-of-endpoints",level:3},{value:"Specify durability type",id:"specify-durability-type",level:3},{value:"Key/Values: Usage &amp; Examples",id:"keyvalues-usage--examples",level:2},{value:"Transactions",id:"transactions",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"client-for-net",children:"Client for .NET"})}),"\n",(0,t.jsxs)(n.p,{children:["Kahuna also provides a client tailored for .NET developers. This client simplifies the integration of distributed locking into your .NET applications by abstracting much of the underlying complexity. Documentation and samples for the client can be found in the ",(0,t.jsx)(n.code,{children:"docs/"})," folder or on our ",(0,t.jsx)(n.a,{href:"https://github.com/kahunakv/kahuna",children:"GitHub repository"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"client-installation",children:"Client Installation"}),"\n",(0,t.jsx)(n.p,{children:"Kahuna Client for .NET is available as a NuGet package. You can install it via the .NET CLI:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"dotnet add package Kahuna.Client\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or via the NuGet Package Manager:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-powershell",children:"Install-Package Kahuna.Client\n"})}),"\n",(0,t.jsx)(n.h2,{id:"locks-usage--examples",children:"Locks: Usage & Examples"}),"\n",(0,t.jsx)(n.h3,{id:"single-attempt-to-acquire-a-lock",children:"Single attempt to acquire a lock"}),"\n",(0,t.jsx)(n.p,{children:"Below is a basic example to demonstrate how to use Kahuna Distributed Locks in a C# project:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Kahuna.Client;\n\n// Create a Kahuna client (it can be a global instance)\nvar client = new KahunaClient("https://localhost:8082");\n\n// ...\n\npublic async Task UpdateBalance(KahunaClient client, string userId)\n{\n    // try to lock on a resource using a keyName composed of a prefix and the user\'s id,\n    // if acquired then automatically release the lock after 5 seconds (if not extended),\n    // it will give up immediately if the lock is not available,\n    // if the lock is acquired it will prevent the same user from changing the same data concurrently\n\n    await using KahunaLock myLock = await client.GetOrCreateLock(\n        "balance-" + userId, \n        TimeSpan.FromSeconds(5)\n    );\n\n    if (myLock.IsAcquired)\n    {\n        Console.WriteLine("Lock acquired!");\n\n        // implement exclusive logic here\n    }\n    else\n    {\n        Console.WriteLine("Someone else has the lock!");\n    }\n\n    // myLock is automatically released after leaving the method\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"multiple-attempts-to-acquire-a-lock",children:"Multiple attempts to acquire a lock"}),"\n",(0,t.jsx)(n.p,{children:"The following example shows how to make multiple attempts to acquire a lock (lease) for 10 seconds, retrying every 150 ms."}),"\n",(0,t.jsx)(n.p,{children:"Why Frequent Retries? Given that inventory updates are very short operations (typically milliseconds to a few seconds),\neach update releases the lock quickly. Still, with a massive volume of concurrent purchase attempts, the lock is rapidly cycled through many clients.\nAs a result, individual servers might find that the lock is released often, but due to high contention,\nthey need to retry multiple times until one of them succeeds."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Kahuna.Client;\n\npublic async Task UpdateBalance(KahunaClient client, string userId)\n{\n    // try to lock on a resource using a keyName composed of a prefix (balance) and the user\'s id,\n    // if acquired then automatically release the lock after 5 seconds or when leaving the method (if not extended),\n    // if not acquired retry to acquire the lock every 150 milliseconds for 10 seconds,\n    // it will give up after 10 seconds if the lock is not available,\n    // if the lock is acquired it will prevent the same user from changing the balance concurrently\n\n    await using KahunaLock myLock = await client.GetOrCreateLock(\n        "balance-" + userId,\n        expiry: TimeSpan.FromSeconds(5),\n        wait: TimeSpan.FromSeconds(10),\n        retry: TimeSpan.FromMilliseconds(150)\n    );\n\n    if (myLock.IsAcquired)\n    {\n        Console.WriteLine("Lock acquired!");\n\n        // implement exclusive logic here\n    }\n    else\n    {\n        Console.WriteLine("Someone else has the lock!");\n    }\n\n    // myLock is automatically released after leaving the method\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"fencing-tokens",children:"Fencing Tokens"}),"\n",(0,t.jsx)(n.p,{children:"Whenever possible, it is also important to use the fencing tokens.\nEven if a client thinks it holds the lock post-lease expiration, fencing tokens prevent stale writes.\nIn this example, the fencing token is used to perform optimistic locking:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Kahuna.Client;\n\npublic async Task IncreaseBalance(KahunaClient client, string userId, long amount)\n{\n    // try to lock on a resource holding the lease for 5 seconds\n    // and prevent stale clients from modifying data after losing their lock.\n\n    await using KahunaLock myLock = await client.GetOrCreateLock(\n        "balance-" + userId,\n        expiry: TimeSpan.FromSeconds(5)\n    );\n\n    if (myLock.IsAcquired)\n    {\n        Console.WriteLine("Lock acquired!");\n\n        BalanceAccount account = await db.GetBalance(userId);\n\n        if (account.FencingToken > myLock.FencingToken)\n        {\n            // Write rejected: Stale fencing token\n\n            Console.WriteLine("Someone else had the lock!");\n            return;\n        }\n\n        // Write successful: New balance saved with new fencing token\n\n        account.Balance += amount;\n        account.FencingToken = myLock.FencingToken;\n\n        await db.Save(account);\n    }\n    else\n    {\n        Console.WriteLine("Someone else has the lock!");\n    }\n\n    // myLock is automatically released after leaving the method\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"periodically-extend-a-lock",children:"Periodically extend a lock"}),"\n",(0,t.jsx)(n.p,{children:"At times, it is useful to periodically extend the lock's expiration time while a client holds it, for example, in a leader election scenario.\nAs long as the leader node is alive and healthy, it can extend the lock duration to signal that it can continue acting as the leader:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Kahuna.Client;\n\npublic async Task TryChooseLeader(KahunaClient client, string groupId)\n{\n    await using KahunaLock myLock = await client.GetOrCreateLock(\n        "group-leader-" + groupId,\n        expiry: TimeSpan.FromSeconds(10)\n    );\n\n    if (!myLock.IsAcquired)\n    {\n        Console.WriteLine("Lock not acquired!");\n        return;\n    }\n\n    long acquireFencingToken = myLock.FencingToken;\n\n    while (true)\n    {\n        (bool isExtended, long fencingToken) = await myLock.TryExtend(TimeSpan.FromSeconds(10));\n        if (!isExtended)\n        {\n            Console.WriteLine("Lock extension failed!");\n            break;\n        }\n\n        if (fencingToken != acquireFencingToken)\n        {\n            Console.WriteLine("Lock fencing token changed! Someone else took the lock");\n            break;\n        }\n\n        // wait 5 seconds to extend the lock\n        await Task.Delay(5000);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"retrieve-information-about-a-lock",children:"Retrieve information about a lock"}),"\n",(0,t.jsx)(n.p,{children:"You can also retrieve information about a lock, such as the current lock's owner and remaining time for the lock to expire:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Kahuna.Client;\n\npublic async Task TryChooseLeader(KahunaClient client, string groupId)\n{\n    await using KahunaLock myLock = await client.GetOrCreateLock(\n        "group-leader-" + groupId,\n        expiry: TimeSpan.FromSeconds(5)\n    );\n\n    if (!myLock.IsAcquired)\n    {\n        Console.WriteLine("Lock not acquired!");\n\n        var lockInfo = await myLock.GetInfo();\n\n        Console.WriteLine($"Lock owner: {lockInfo.Owner}");\n        Console.WriteLine($"Expires: {lockInfo.Expires}");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"configure-a-pool-of-endpoints",children:"Configure a pool of endpoints"}),"\n",(0,t.jsx)(n.p,{children:"If you want to configure a pool of Kahuna endpoints belonging to the same cluster so that traffic is distributed in a round-robin manner:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Kahuna.Client;\n\n// Create a Kahuna client with a pool of endpoints\nvar client = new KahunaClient([\n    "https://localhost:8082",\n    "https://localhost:8084",\n    "https://localhost:8086"\n]);\n\n// ...\n'})}),"\n",(0,t.jsx)(n.p,{children:"Using a pool of reachable endpoints instead of a load balancer can help reduce network latency, as the client can connect directly to healthy nodes without going through an additional proxy layer."}),"\n",(0,t.jsx)(n.p,{children:"However, this comes at the cost of reduced flexibility when adding, removing, or reconfiguring nodes in the cluster. Without a centralized load balancer, the client must be manually updated or be able to discover and manage endpoint changes dynamically."}),"\n",(0,t.jsx)(n.p,{children:"This trade-off is common in high-performance distributed systems that prioritize low latency and direct communication over automatic infrastructure abstraction."}),"\n",(0,t.jsx)(n.h3,{id:"specify-durability-type",children:"Specify durability type"}),"\n",(0,t.jsx)(n.p,{children:"You can also specify the desired durability type when acquiring a lock:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Kahuna.Client;\n\npublic async Task UpdateBalance(KahunaClient client, string userId)\n{\n    // acquire a lock with persistent durability, ensuring that the lock state is\n    // replicated across all nodes in the Kahuna cluster\n    // in case of failure or network partition, the lock state is guaranteed to be durable\n\n    await using KahunaLock myLock = await client.GetOrCreateLock(\n        "balance-" + userId,\n        TimeSpan.FromSeconds(300), // lock for 5 mins\n        durability: LockDurability.Persistent\n    );\n\n    if (myLock.IsAcquired)\n    {\n        Console.WriteLine("Lock acquired with strong consistency!");\n\n        // implement exclusive logic here\n    }\n    else\n    {\n        Console.WriteLine("Someone else has the lock!");\n    }\n\n    // myLock is automatically released after leaving the method\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Learn more about the supported ",(0,t.jsx)(n.a,{href:"/docs/architecture/durability-levels",children:"durabilities"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"keyvalues-usage--examples",children:"Key/Values: Usage & Examples"}),"\n",(0,t.jsx)(n.h3,{id:"transactions",children:"Transactions"})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>l,x:()=>c});var i=a(6540);const t={},o=i.createContext(t);function l(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);