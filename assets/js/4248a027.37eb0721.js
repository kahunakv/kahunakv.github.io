"use strict";(self.webpackChunkkahunakv_docs=self.webpackChunkkahunakv_docs||[]).push([[8947],{1345:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"distributed-keyvalue-store/transactions","title":"Transactions","description":"Overview","source":"@site/docs/distributed-keyvalue-store/transactions.md","sourceDirName":"distributed-keyvalue-store","slug":"/distributed-keyvalue-store/transactions","permalink":"/docs/distributed-keyvalue-store/transactions","draft":false,"unlisted":false,"editUrl":"https://github.com/kahunakv/kahunakv.github.io/tree/main/docs/distributed-keyvalue-store/transactions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Key Distribution and Buckets","permalink":"/docs/distributed-keyvalue-store/buckets"},"next":{"title":"Distributed Sequencer","permalink":"/docs/distributed-sequencer"}}');var t=s(4848),r=s(8453);const c={},l="Transactions",a={},o=[{value:"Overview",id:"overview",level:2},{value:"Why Transactions Matter?",id:"why-transactions-matter",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Transaction API",id:"transaction-api",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Example: Conditional Write Based on a Snapshot",id:"example-conditional-write-based-on-a-snapshot",level:3},{value:"Using <code>get by prefix</code> inside a Transaction",id:"using-get-by-prefix-inside-a-transaction",level:2},{value:"Transaction Lifecycle",id:"transaction-lifecycle",level:2},{value:"Durability Modes in Transactions",id:"durability-modes-in-transactions",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Transaction Options",id:"transaction-options",level:2},{value:"Timeout",id:"timeout",level:3},{value:"Locking",id:"locking",level:3},{value:"AsyncRelease",id:"asyncrelease",level:3},{value:"AutoCommit",id:"autocommit",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"transactions",children:"Transactions"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["Kahuna offers ",(0,t.jsx)(n.strong,{children:"distributed transactions"})," to enable safe, consistent, and atomic access to keys across the cluster. Transactions ensure that multiple reads and writes either all succeed together or none take effect\u2014making them essential for maintaining ",(0,t.jsx)(n.strong,{children:"data correctness"})," in concurrent and distributed environments."]}),"\n",(0,t.jsxs)(n.p,{children:["Kahuna supports ",(0,t.jsx)(n.strong,{children:"snapshot isolation"})," and ",(0,t.jsx)(n.strong,{children:"serializable consistency"})," through ",(0,t.jsx)(n.strong,{children:"MVCC (Multi-Version Concurrency Control)"})," and ",(0,t.jsx)(n.strong,{children:"optimistic/pessimistic locking"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"why-transactions-matter",children:"Why Transactions Matter?"}),"\n",(0,t.jsx)(n.p,{children:"In a distributed system, multiple clients might access and modify overlapping sets of keys. Without transactions, you risk:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lost updates"})," (e.g., one client overwriting another)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Read skew"})," (inconsistent reads during writes)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Partial updates"})," (only some keys being modified)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Kahuna\u2019s transactional engine addresses these issues by:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Isolating reads and writes from each other using ",(0,t.jsx)(n.strong,{children:"MVCC"})," versions"]}),"\n",(0,t.jsx)(n.li,{children:"Detecting write conflicts during commit"}),"\n",(0,t.jsxs)(n.li,{children:["Optionally acquiring ",(0,t.jsx)(n.strong,{children:"locks"})," to serialize conflicting transactions"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Concept"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Snapshot Isolation"})}),(0,t.jsx)(n.td,{children:"Readers see a consistent snapshot of the data as of the transaction start. Writers commit only if no conflicting writes occurred."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Serializable Transactions"})}),(0,t.jsx)(n.td,{children:"Pessimistic locks can be used to enforce total ordering of transactions."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"MVCC"})}),(0,t.jsx)(n.td,{children:"Each key maintains multiple versions. Reads select the correct version based on transaction timestamp."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Transaction Timestamp"})}),(0,t.jsxs)(n.td,{children:["A ",(0,t.jsx)(n.a,{href:"/docs/architecture/hybrid-logical-clocks",children:"Hybrid Logical Clock (HLC)"})," timestamp assigned at transaction start, used for snapshot reads and version tracking."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Write Set"})}),(0,t.jsx)(n.td,{children:"The keys a transaction intends to modify."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Read Set"})}),(0,t.jsx)(n.td,{children:"The keys a transaction read; used for conflict detection."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Locks"})}),(0,t.jsx)(n.td,{children:"Optional. Acquired for pessimistic or serialized transactions. Locks have expiration to prevent being held forever."})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"transaction-api",children:"Transaction API"}),"\n",(0,t.jsx)(n.p,{children:"All operations in a Kahuna Script are implicitly part of a transaction:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'set "services/auth" "localhost:8081"\nset "services/matchmaking" "localhost:8082"\nset "services/inventory" "localhost:8083"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'begin \n let current_alice = get "balance:alice"\n let current_bob = get "balance:alice"\n if current_alice >= 50 then\n  set "balance:alice" current - 50\n  set "balance:bob" current + 50\n end\n commit\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"example-conditional-write-based-on-a-snapshot",children:"Example: Conditional Write Based on a Snapshot"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'begin\n let config = get "settings/feature-x"\n if config == "enabled" then\n   set "logs/feature-x" "used"\n end\n commit\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Even if ",(0,t.jsx)(n.code,{children:"feature-x"})," is disabled mid-transaction by another client, the snapshot ensures this transaction still sees the older version and behaves consistently."]}),"\n",(0,t.jsxs)(n.h2,{id:"using-get-by-prefix-inside-a-transaction",children:["Using ",(0,t.jsx)(n.code,{children:"get by prefix"})," inside a Transaction"]}),"\n",(0,t.jsxs)(n.p,{children:["All keys in a given ",(0,t.jsx)(n.strong,{children:"bucket prefix"})," (e.g., ",(0,t.jsx)(n.code,{children:"services/"}),") are guaranteed to be on the same partition. This enables ",(0,t.jsx)(n.strong,{children:"prefix scans"})," to be consistent and transactional:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'begin\n let services = get by prefix "services"\n if not contains(services, "services/users") then\n  set "services/users" "localhost:8084"\n end\n commit\nend \n'})}),"\n",(0,t.jsxs)(n.p,{children:["Learn more about buckets and keys distribution in the ",(0,t.jsx)(n.a,{href:"buckets",children:"previous section"})]}),"\n",(0,t.jsx)(n.h2,{id:"transaction-lifecycle",children:"Transaction Lifecycle"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Begin"}),": Kahuna assigns an HLC timestamp and starts tracking reads/writes. Locks are acquired in advance in pessimistic locking."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Read/Write"}),": All operations are buffered in-memory."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validation"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If optimistic: Check for conflicts with newer committed versions."}),"\n",(0,t.jsx)(n.li,{children:"If pessimistic: Lock keys ahead of time to avoid conflicts."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Commit"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If successful, MVCC versions are written and optionally replicated (persistent mode)."}),"\n",(0,t.jsx)(n.li,{children:"If failed, changes are discarded and client is notified."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Learn more about transaction lifecycle in the ",(0,t.jsx)(n.a,{href:"/docs/architecture/distributed-transactions",children:"architecture"})," section."]}),"\n",(0,t.jsx)(n.h2,{id:"durability-modes-in-transactions",children:"Durability Modes in Transactions"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Mode"}),(0,t.jsx)(n.th,{children:"Behavior"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Persistent"})}),(0,t.jsx)(n.td,{children:"Commits are replicated and flushed to disk using Raft. Strong durability guarantees."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Ephemeral"})}),(0,t.jsx)(n.td,{children:"For lightweight, non-persistent use cases (e.g., caching, temporary locks). Faster but not durable."})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'begin \n eset "session:abc" "active" # session is stored in ephemeral durability (in-memory)\n set "session:xyz" "active" # session is stored in persistent durability (disk)\n commit\nend \n'})}),"\n",(0,t.jsxs)(n.p,{children:["Learn more about durabilities in the ",(0,t.jsx)(n.a,{href:"/docs/architecture/durability-levels",children:"dedicated section"})]}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Group keys by prefix"})," when designing schemas to maximize transactional locality."]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.strong,{children:"ephemeral keys"})," for high-speed, non-critical paths."]}),"\n",(0,t.jsxs)(n.li,{children:["Consider ",(0,t.jsx)(n.strong,{children:"pessimistic locking"})," for highly contended keys to avoid retries."]}),"\n",(0,t.jsxs)(n.li,{children:["Monitor retries to detect ",(0,t.jsx)(n.strong,{children:"hotspots"})," in your workload."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"transaction-options",children:"Transaction Options"}),"\n",(0,t.jsxs)(n.p,{children:["You can specify ",(0,t.jsx)(n.strong,{children:"transaction options"})," to fine-tune how the transaction is executed:"]}),"\n",(0,t.jsx)(n.h3,{id:"timeout",children:"Timeout"}),"\n",(0,t.jsxs)(n.p,{children:["Specifies the ",(0,t.jsx)(n.strong,{children:"maximum duration (in milliseconds)"})," that the transaction is allowed to run.\nIf the transaction does not complete within this time, it will be ",(0,t.jsx)(n.strong,{children:"automatically rolled back"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Kahuna Scripts are designed for ",(0,t.jsx)(n.strong,{children:"short executions"}),", so increasing this value significantly is ",(0,t.jsx)(n.strong,{children:"not recommended"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Default value:"})," ",(0,t.jsx)(n.code,{children:"5000ms"})]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"begin (timeout=3000)\n  set `config1` 'some value 1'\n  set `config2` 'some value 2'\n  set `config3` 'some value 3'\n  commit\nend\n"})}),"\n",(0,t.jsx)(n.h3,{id:"locking",children:"Locking"}),"\n",(0,t.jsxs)(n.p,{children:["Defines the ",(0,t.jsx)(n.strong,{children:"locking strategy"})," used by the transaction."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"pessimistic"}),": Locks keys upfront to ensure full consistency."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"optimistic"}),": Locks only on write, with version validation during commit."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Default value:"})," ",(0,t.jsx)(n.code,{children:"pessimistic"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"begin (locking=\"optimistic\")\n  set `config1` 'some value 1'\n  set `config2` 'some value 2'\n  set `config3` 'some value 3'\n  commit\nend\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"asyncrelease",children:"AsyncRelease"}),"\n",(0,t.jsxs)(n.p,{children:["Indicates whether acquired locks should be ",(0,t.jsx)(n.strong,{children:"released asynchronously"})," (in the background) or ",(0,t.jsx)(n.strong,{children:"synchronously"})," (blocking the client until fully released)."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"true"}),": Faster response to the client, locks released in background."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"false"}),": Locks must be released before returning to the client."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Default value:"})," ",(0,t.jsx)(n.code,{children:"false"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"begin (asyncRelease=\"true\")\n  set `config1` 'some value 1'\n  set `config2` 'some value 2'\n  set `config3` 'some value 3'\n  commit\nend\n"})}),"\n",(0,t.jsx)(n.h3,{id:"autocommit",children:"AutoCommit"}),"\n",(0,t.jsxs)(n.p,{children:["Specifies whether an ",(0,t.jsxs)(n.strong,{children:["implicit ",(0,t.jsx)(n.code,{children:"commit"})]})," should be executed automatically if all operations in the transaction succeed, or if an ",(0,t.jsxs)(n.strong,{children:["explicit ",(0,t.jsx)(n.code,{children:"commit"})]})," is required to finalize the transaction."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"true"}),": The transaction will ",(0,t.jsx)(n.strong,{children:"automatically commit"})," if no errors occur."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"false"}),": A manual ",(0,t.jsx)(n.code,{children:"commit()"})," is required to indicate when the transaction should be finalized."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Default behavior:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"false"})," when using a ",(0,t.jsx)(n.code,{children:"begin"})," block"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"true"})," when no ",(0,t.jsx)(n.code,{children:"begin"})," block is used"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"begin (autoCommit=false)\n  ...\n  commit\nend\n"})}),"\n",(0,t.jsxs)(n.p,{children:["These options provide greater flexibility and control over ",(0,t.jsx)(n.strong,{children:"performance"}),", ",(0,t.jsx)(n.strong,{children:"consistency"}),", and ",(0,t.jsx)(n.strong,{children:"responsiveness"})," in your Kahuna transactions."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>l});var i=s(6540);const t={},r=i.createContext(t);function c(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);