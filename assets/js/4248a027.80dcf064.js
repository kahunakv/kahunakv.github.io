"use strict";(self.webpackChunkkahunakv_docs=self.webpackChunkkahunakv_docs||[]).push([[8947],{1345:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>x,frontMatter:()=>l,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"distributed-keyvalue-store/transactions","title":"Transactions","description":"Overview","source":"@site/docs/distributed-keyvalue-store/transactions.md","sourceDirName":"distributed-keyvalue-store","slug":"/distributed-keyvalue-store/transactions","permalink":"/docs/distributed-keyvalue-store/transactions","draft":false,"unlisted":false,"editUrl":"https://github.com/kahunakv/kahunakv.github.io/tree/main/docs/distributed-keyvalue-store/transactions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Revisions","permalink":"/docs/distributed-keyvalue-store/revisions"},"next":{"title":"Key Distribution and Buckets","permalink":"/docs/distributed-keyvalue-store/buckets"}}');var t=s(4848),r=s(8453),a=s(5537),c=s(9329);const l={},o="Transactions",d={},h=[{value:"Overview",id:"overview",level:2},{value:"Why Transactions Matter?",id:"why-transactions-matter",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Transaction API",id:"transaction-api",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Example: Conditional Write Based on a Snapshot",id:"example-conditional-write-based-on-a-snapshot",level:3},{value:"Using <code>get by prefix</code> inside a Transaction",id:"using-get-by-prefix-inside-a-transaction",level:2},{value:"Transaction Lifecycle",id:"transaction-lifecycle",level:2},{value:"Durability Modes in Transactions",id:"durability-modes-in-transactions",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Transaction Options",id:"transaction-options",level:2},{value:"Timeout",id:"timeout",level:3},{value:"Locking",id:"locking",level:3},{value:"AsyncRelease",id:"asyncrelease",level:3},{value:"AutoCommit",id:"autocommit",level:3},{value:"Interactive Transactions",id:"interactive-transactions",level:2},{value:"Interactive Transactions vs Kahuna Scripts",id:"interactive-transactions-vs-kahuna-scripts",level:2},{value:"Interactive Transactions",id:"interactive-transactions-1",level:3},{value:"Kahuna Scripts",id:"kahuna-scripts",level:3}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"transactions",children:"Transactions"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["Kahuna offers ",(0,t.jsx)(n.strong,{children:"distributed transactions"})," to enable safe, consistent, and atomic access to keys across the cluster. Transactions ensure that multiple reads and writes either all succeed together or none take effect\u2014making them essential for maintaining ",(0,t.jsx)(n.strong,{children:"data correctness"})," in concurrent and distributed environments."]}),"\n",(0,t.jsxs)(n.p,{children:["Kahuna supports ",(0,t.jsx)(n.strong,{children:"snapshot isolation"})," and ",(0,t.jsx)(n.strong,{children:"serializable consistency"})," through ",(0,t.jsx)(n.strong,{children:"MVCC (Multi-Version Concurrency Control)"})," and ",(0,t.jsx)(n.strong,{children:"optimistic/pessimistic locking"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"why-transactions-matter",children:"Why Transactions Matter?"}),"\n",(0,t.jsx)(n.p,{children:"In a distributed system, multiple clients might access and modify overlapping sets of keys. Without transactions, you risk:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lost updates"})," (e.g., one client overwriting another)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Read skew"})," (inconsistent reads during writes)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Partial updates"})," (only some keys being modified)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Kahuna\u2019s transactional engine addresses these issues by:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Isolating reads and writes from each other using ",(0,t.jsx)(n.strong,{children:"MVCC"})," versions"]}),"\n",(0,t.jsx)(n.li,{children:"Detecting write conflicts during commit"}),"\n",(0,t.jsxs)(n.li,{children:["Optionally acquiring ",(0,t.jsx)(n.strong,{children:"locks"})," to serialize conflicting transactions"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Concept"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Snapshot Isolation"})}),(0,t.jsx)(n.td,{children:"Readers see a consistent snapshot of the data as of the transaction start. Writers commit only if no conflicting writes occurred."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Serializable Transactions"})}),(0,t.jsx)(n.td,{children:"Pessimistic locks can be used to enforce total ordering of transactions."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"MVCC"})}),(0,t.jsx)(n.td,{children:"Each key maintains multiple versions. Reads select the correct version based on transaction timestamp."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Transaction Timestamp"})}),(0,t.jsxs)(n.td,{children:["A ",(0,t.jsx)(n.a,{href:"/docs/architecture/hybrid-logical-clocks",children:"Hybrid Logical Clock (HLC)"})," timestamp assigned at transaction start, used for snapshot reads and version tracking."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Write Set"})}),(0,t.jsx)(n.td,{children:"The keys a transaction intends to modify."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Read Set"})}),(0,t.jsx)(n.td,{children:"The keys a transaction read; used for conflict detection."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Locks"})}),(0,t.jsx)(n.td,{children:"Optional. Acquired for pessimistic or serialized transactions. Locks have expiration to prevent being held forever."})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"transaction-api",children:"Transaction API"}),"\n",(0,t.jsx)(n.p,{children:"All operations in a Kahuna Script are implicitly part of a transaction:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'set "services/auth" "localhost:8081"\nset "services/matchmaking" "localhost:8082"\nset "services/inventory" "localhost:8083"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'begin\n let current_alice = get "balance:alice"\n let current_bob = get "balance:alice"\n if current_alice >= 50 then\n  set "balance:alice" current - 50\n  set "balance:bob" current + 50\n end\n commit\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"example-conditional-write-based-on-a-snapshot",children:"Example: Conditional Write Based on a Snapshot"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'begin\n let config = get "settings/feature-x"\n if config == "enabled" then\n   set "logs/feature-x" "used"\n end\n commit\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Even if ",(0,t.jsx)(n.code,{children:"feature-x"})," is disabled mid-transaction by another client, the snapshot ensures this transaction still sees the older version and behaves consistently."]}),"\n",(0,t.jsxs)(n.h2,{id:"using-get-by-prefix-inside-a-transaction",children:["Using ",(0,t.jsx)(n.code,{children:"get by prefix"})," inside a Transaction"]}),"\n",(0,t.jsxs)(n.p,{children:["All keys in a given ",(0,t.jsx)(n.strong,{children:"bucket prefix"})," (e.g., ",(0,t.jsx)(n.code,{children:"services/"}),") are guaranteed to be on the same partition. This enables ",(0,t.jsx)(n.strong,{children:"prefix scans"})," to be consistent and transactional:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'begin\n let services = get by prefix "services"\n if not contains(services, "services/users") then\n  set "services/users" "localhost:8084"\n end\n commit\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Learn more about buckets and keys distribution in the ",(0,t.jsx)(n.a,{href:"buckets",children:"previous section"})]}),"\n",(0,t.jsx)(n.h2,{id:"transaction-lifecycle",children:"Transaction Lifecycle"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Begin"}),": Kahuna assigns an HLC timestamp and starts tracking reads/writes. Locks are acquired in advance in pessimistic locking."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Read/Write"}),": All operations are buffered in-memory."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validation"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If optimistic: Check for conflicts with newer committed versions."}),"\n",(0,t.jsx)(n.li,{children:"If pessimistic: Lock keys ahead of time to avoid conflicts."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Commit"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If successful, MVCC versions are written and optionally replicated (persistent mode)."}),"\n",(0,t.jsx)(n.li,{children:"If failed, changes are discarded and client is notified."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Learn more about transaction lifecycle in the ",(0,t.jsx)(n.a,{href:"/docs/architecture/distributed-transactions",children:"architecture"})," section."]}),"\n",(0,t.jsx)(n.h2,{id:"durability-modes-in-transactions",children:"Durability Modes in Transactions"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Mode"}),(0,t.jsx)(n.th,{children:"Behavior"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Persistent"})}),(0,t.jsx)(n.td,{children:"Commits are replicated and flushed to disk using Raft. Strong durability guarantees."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Ephemeral"})}),(0,t.jsx)(n.td,{children:"For lightweight, non-persistent use cases (e.g., caching, temporary locks). Faster but not durable."})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'begin\n eset "session:abc" "active" # session is stored in ephemeral durability (in-memory)\n set "session:xyz" "active" # session is stored in persistent durability (disk)\n commit\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Learn more about durabilities in the ",(0,t.jsx)(n.a,{href:"/docs/architecture/durability-levels",children:"dedicated section"})]}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Group keys by prefix"})," when designing schemas to maximize transactional locality."]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.strong,{children:"ephemeral keys"})," for high-speed, non-critical paths."]}),"\n",(0,t.jsxs)(n.li,{children:["Consider ",(0,t.jsx)(n.strong,{children:"pessimistic locking"})," for highly contended keys to avoid retries."]}),"\n",(0,t.jsxs)(n.li,{children:["Monitor retries to detect ",(0,t.jsx)(n.strong,{children:"hotspots"})," in your workload."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"transaction-options",children:"Transaction Options"}),"\n",(0,t.jsxs)(n.p,{children:["You can specify ",(0,t.jsx)(n.strong,{children:"transaction options"})," to fine-tune how the transaction is executed. These options provide greater flexibility and control over ",(0,t.jsx)(n.strong,{children:"performance"}),", ",(0,t.jsx)(n.strong,{children:"consistency"}),", and ",(0,t.jsx)(n.strong,{children:"responsiveness"}),":"]}),"\n",(0,t.jsx)(n.h3,{id:"timeout",children:"Timeout"}),"\n",(0,t.jsxs)(n.p,{children:["Specifies the ",(0,t.jsx)(n.strong,{children:"maximum duration (in milliseconds)"})," that the transaction is allowed to run.\nIf the transaction does not complete within this time, it will be ",(0,t.jsx)(n.strong,{children:"automatically rolled back"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Kahuna Scripts are designed for ",(0,t.jsx)(n.strong,{children:"short executions"}),", so increasing this value significantly is ",(0,t.jsx)(n.strong,{children:"not recommended"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Default value:"})," ",(0,t.jsx)(n.code,{children:"5000ms"})]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"begin (timeout=3000)\n  set `config1` 'some value 1'\n  set `config2` 'some value 2'\n  set `config3` 'some value 3'\n  commit\nend\n"})}),"\n",(0,t.jsx)(n.h3,{id:"locking",children:"Locking"}),"\n",(0,t.jsxs)(n.p,{children:["Defines the ",(0,t.jsx)(n.strong,{children:"locking strategy"})," used by the transaction."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"pessimistic"}),": Locks keys upfront to ensure full consistency."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"optimistic"}),": Locks only on write, with version validation during commit."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Default value:"})," ",(0,t.jsx)(n.code,{children:"pessimistic"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"begin (locking=\"optimistic\")\n  set `config1` 'some value 1'\n  set `config2` 'some value 2'\n  set `config3` 'some value 3'\n  commit\nend\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"asyncrelease",children:"AsyncRelease"}),"\n",(0,t.jsxs)(n.p,{children:["Indicates whether acquired locks should be ",(0,t.jsx)(n.strong,{children:"released asynchronously"})," (in the background) or ",(0,t.jsx)(n.strong,{children:"synchronously"})," (blocking the client until fully released)."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"true"}),": Faster response to the client, locks released in background."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"false"}),": Locks must be released before returning to the client."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Default value:"})," ",(0,t.jsx)(n.code,{children:"false"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"begin (asyncRelease=\"true\")\n  set `config1` 'some value 1'\n  set `config2` 'some value 2'\n  set `config3` 'some value 3'\n  commit\nend\n"})}),"\n",(0,t.jsx)(n.h3,{id:"autocommit",children:"AutoCommit"}),"\n",(0,t.jsxs)(n.p,{children:["Specifies whether an ",(0,t.jsxs)(n.strong,{children:["implicit ",(0,t.jsx)(n.code,{children:"commit"})]})," should be executed automatically if all operations in the transaction succeed, or if an ",(0,t.jsxs)(n.strong,{children:["explicit ",(0,t.jsx)(n.code,{children:"commit"})]})," is required to finalize the transaction."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"true"}),": The transaction will ",(0,t.jsx)(n.strong,{children:"automatically commit"})," if no errors occur."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"false"}),": A manual ",(0,t.jsx)(n.code,{children:"commit()"})," is required to indicate when the transaction should be finalized."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Default behavior:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"false"})," when using a ",(0,t.jsx)(n.code,{children:"begin"})," block"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"true"})," when no ",(0,t.jsx)(n.code,{children:"begin"})," block is used"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"begin (autoCommit=false)\n  ...\n  commit\nend\n"})}),"\n",(0,t.jsx)(n.h2,{id:"interactive-transactions",children:"Interactive Transactions"}),"\n",(0,t.jsx)(n.p,{children:"Interactive transactions are an option for developers who prefer not to use Kahuna Scripts and instead want access to the libraries and functions of their favorite programming language."}),"\n",(0,t.jsx)(n.p,{children:"These transactions work similarly to traditional database transactions, where the client must manually start a transaction and then commit or rollback it as needed, depending on the outcome:"}),"\n",(0,t.jsx)(a.A,{children:(0,t.jsxs)(c.A,{value:"C#",children:[(0,t.jsx)(n.p,{children:"The Kahuna client for C# offers full support for interactive transactions."}),(0,t.jsx)(n.p,{children:"This allows developers to start, manage, and complete transactions directly from their C# applications, giving them fine-grained control over the flow of operations while maintaining strong consistency guarantees provided by Kahuna:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'await using KahunaTransactionSession session = await client.StartTransactionSession(\n    new() {\n      Locking = KeyValueTransactionLocking.Optimistic,\n      Timeout = 5000\n    }\n);\n\nKahunaKeyValue balance1 = await session.GetKeyValue(keyNameA);\nKahunaKeyValue balance2 = await session.GetKeyValue(keyNameB);\n\nif (int.Parse(balance1.ValueAsString() ?? "0") + int.Parse(balance2.ValueAsString() ?? "0") == 20)\n    await session.SetKeyValue(keyNameA, "0");\n\nawait session2.Commit();\n'})})]})}),"\n",(0,t.jsx)(n.p,{children:"This approach gives developers more flexibility to build complex logic in the application layer while still benefiting from Kahuna\u2019s consistency and durability guarantees."}),"\n",(0,t.jsx)(n.h2,{id:"interactive-transactions-vs-kahuna-scripts",children:"Interactive Transactions vs Kahuna Scripts"}),"\n",(0,t.jsx)(n.p,{children:"Both Interactive Transactions and Kahuna Scripts offer powerful ways to work with Kahuna\u2019s distributed system, each with distinct trade-offs.\nInteractive Transactions provide greater flexibility and ease of integration with application code but at the cost of higher network latency and complexity in failure scenarios."}),"\n",(0,t.jsx)(n.p,{children:"Kahuna Scripts, on the other hand, deliver atomicity, reduced latency, and automatic lock management, making them ideal for critical operations that need to execute entirely on the server \u2014 although they require familiarity with a specialized scripting environment."}),"\n",(0,t.jsx)(n.p,{children:"Choosing between the two approaches depends on the specific needs of your application, the complexity of your logic, and your tolerance for latency versus maintenance effort:"}),"\n",(0,t.jsx)(n.h3,{id:"interactive-transactions-1",children:"Interactive Transactions"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Advantages"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Familiarity and Easier Debugging"}),": You write the logic in your primary programming language (C#, JavaScript, etc.), making it easier to debug, maintain, and integrate with your development tools."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Better Integration"}),": Interactive transactions work seamlessly with application-level logic, error handling, and native data structures."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Disadvantages"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Increased Latency"}),": Requires multiple round-trips between the client and server, which can introduce additional delays."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Graceful Degradation Challenges"}),": In the event of partial failures (e.g., network partitions), the client may be unable to manually commit or roll back transactions. Locks could be held until the transaction times out. This can be mitigated by setting short transaction timeouts (a few seconds)."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"kahuna-scripts",children:"Kahuna Scripts"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Advantages"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Atomic Execution"}),": The entire script executes atomically on the server (transaction coordinator), as long as there are no node failures or abnormal inter-node network conditions."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Automatic Lock Management"}),": Kahuna Scripts automatically release acquired locks in the presence of conflicts, reducing complexity and avoiding unwanted delays or retries."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Supports Complex Logic"}),": Scripts can include conditionals (",(0,t.jsx)(n.code,{children:"if"}),", ",(0,t.jsx)(n.code,{children:"while"}),", etc.), loops, functions, and branching logic directly on the server."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Shared and Portable Logic"}),": The same Kahuna Script can be executed from multiple programming languages without modification or extra maintenance."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reduced Round-Trips"}),": Operations are fully executed server-side, minimizing network latency between client and server."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Disadvantages"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Potentially Harder to Maintain"}),": Kahuna Script syntax may be less familiar and harder to debug or test compared to your main programming language."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Script Size Limitations"}),": Large or complex business logic may be difficult to express and maintain within Kahuna Scripts."]}),"\n"]})]})}function x(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},5537:(e,n,s)=>{s.d(n,{A:()=>k});var i=s(6540),t=s(4164),r=s(5627),a=s(6347),c=s(372),l=s(604),o=s(1861),d=s(8749);function h(e){return i.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:s}=e;return(0,i.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:s,attributes:i,default:t}}=e;return{value:n,label:s,attributes:i,default:t}}))}(s);return function(e){const n=(0,o.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,s])}function x(e){let{value:n,tabValues:s}=e;return s.some((e=>e.value===n))}function p(e){let{queryString:n=!1,groupId:s}=e;const t=(0,a.W6)(),r=function(e){let{queryString:n=!1,groupId:s}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!s)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return s??null}({queryString:n,groupId:s});return[(0,l.aZ)(r),(0,i.useCallback)((e=>{if(!r)return;const n=new URLSearchParams(t.location.search);n.set(r,e),t.replace({...t.location,search:n.toString()})}),[r,t])]}function m(e){const{defaultValue:n,queryString:s=!1,groupId:t}=e,r=u(e),[a,l]=(0,i.useState)((()=>function(e){let{defaultValue:n,tabValues:s}=e;if(0===s.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!x({value:n,tabValues:s}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${s.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const i=s.find((e=>e.default))??s[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:r}))),[o,h]=p({queryString:s,groupId:t}),[m,g]=function(e){let{groupId:n}=e;const s=function(e){return e?`docusaurus.tab.${e}`:null}(n),[t,r]=(0,d.Dv)(s);return[t,(0,i.useCallback)((e=>{s&&r.set(e)}),[s,r])]}({groupId:t}),j=(()=>{const e=o??m;return x({value:e,tabValues:r})?e:null})();(0,c.A)((()=>{j&&l(j)}),[j]);return{selectedValue:a,selectValue:(0,i.useCallback)((e=>{if(!x({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);l(e),h(e),g(e)}),[h,g,r]),tabValues:r}}var g=s(9136);const j={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=s(4848);function b(e){let{className:n,block:s,selectedValue:i,selectValue:a,tabValues:c}=e;const l=[],{blockElementScrollPositionUntilNextRender:o}=(0,r.a_)(),d=e=>{const n=e.currentTarget,s=l.indexOf(n),t=c[s].value;t!==i&&(o(n),a(t))},h=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const s=l.indexOf(e.currentTarget)+1;n=l[s]??l[0];break}case"ArrowLeft":{const s=l.indexOf(e.currentTarget)-1;n=l[s]??l[l.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,t.A)("tabs",{"tabs--block":s},n),children:c.map((e=>{let{value:n,label:s,attributes:r}=e;return(0,f.jsx)("li",{role:"tab",tabIndex:i===n?0:-1,"aria-selected":i===n,ref:e=>{l.push(e)},onKeyDown:h,onClick:d,...r,className:(0,t.A)("tabs__item",j.tabItem,r?.className,{"tabs__item--active":i===n}),children:s??n},n)}))})}function v(e){let{lazy:n,children:s,selectedValue:r}=e;const a=(Array.isArray(s)?s:[s]).filter(Boolean);if(n){const e=a.find((e=>e.props.value===r));return e?(0,i.cloneElement)(e,{className:(0,t.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:a.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function y(e){const n=m(e);return(0,f.jsxs)("div",{className:(0,t.A)("tabs-container",j.tabList),children:[(0,f.jsx)(b,{...n,...e}),(0,f.jsx)(v,{...n,...e})]})}function k(e){const n=(0,g.A)();return(0,f.jsx)(y,{...e,children:h(e.children)},String(n))}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>c});var i=s(6540);const t={},r=i.createContext(t);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:n},e.children)}},9329:(e,n,s)=>{s.d(n,{A:()=>a});s(6540);var i=s(4164);const t={tabItem:"tabItem_Ymn6"};var r=s(4848);function a(e){let{children:n,hidden:s,className:a}=e;return(0,r.jsx)("div",{role:"tabpanel",className:(0,i.A)(t.tabItem,a),hidden:s,children:n})}}}]);