"use strict";(self.webpackChunkkahunakv_docs=self.webpackChunkkahunakv_docs||[]).push([[9434],{7013:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"architecture/hybrid-logical-clocks","title":"Hybrid Logical Clocks (HLC)","description":"Overview","source":"@site/docs/architecture/hybrid-logical-clocks.md","sourceDirName":"architecture","slug":"/architecture/hybrid-logical-clocks","permalink":"/docs/architecture/hybrid-logical-clocks","draft":false,"unlisted":false,"editUrl":"https://github.com/kahunakv/kahunakv.github.io/tree/main/docs/architecture/hybrid-logical-clocks.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Raft in Kahuna: Consensus and High Availability System","permalink":"/docs/architecture/raft"},"next":{"title":"Durability Levels","permalink":"/docs/architecture/durability-levels"}}');var t=s(4848),r=s(8453);const c=s.p+"assets/images/hlc-4cb63ae85069fad504bf4b22ca16f58e.png",l={},a="Hybrid Logical Clocks (HLC)",o={},d=[{value:"Overview",id:"overview",level:2},{value:"HLC Format in Kahuna",id:"hlc-format-in-kahuna",level:2},{value:"Use Cases in Kahuna",id:"use-cases-in-kahuna",level:2},{value:"Transaction Timestamps",id:"transaction-timestamps",level:3},{value:"Multi-Version Concurrency Control (MVCC)",id:"multi-version-concurrency-control-mvcc",level:3},{value:"Conflict Detection",id:"conflict-detection",level:3},{value:"Locking and Sequencing",id:"locking-and-sequencing",level:3},{value:"Cluster-Wide Consistency Without TrueTime",id:"cluster-wide-consistency-without-truetime",level:3},{value:"Example: HLC Write Flow in Kahuna",id:"example-hlc-write-flow-in-kahuna",level:2},{value:"Design Advantages",id:"design-advantages",level:2},{value:"HLC Timeline",id:"hlc-timeline",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"hybrid-logical-clocks-hlc",children:"Hybrid Logical Clocks (HLC)"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["Kahuna integrates ",(0,t.jsx)(n.strong,{children:"Hybrid Logical Clocks (HLCs)"})," as a fundamental mechanism to provide ",(0,t.jsx)(n.strong,{children:"causally consistent timestamps"}),", ensure ",(0,t.jsx)(n.strong,{children:"transaction ordering"}),", detect ",(0,t.jsx)(n.strong,{children:"write-write conflicts"}),", and support ",(0,t.jsx)(n.strong,{children:"external consistency"})," without requiring tightly synchronized clocks (like Google's TrueTime)."]}),"\n",(0,t.jsx)(n.p,{children:"Every write, lock, or sequence operation in Kahuna is associated with an HLC timestamp. This unified time model enables distributed coordination and conflict resolution while preserving performance and fault tolerance across nodes."}),"\n",(0,t.jsx)(n.h2,{id:"hlc-format-in-kahuna",children:"HLC Format in Kahuna"}),"\n",(0,t.jsx)(n.p,{children:"Each node in a Kahuna cluster maintains its own HLC state. A timestamp is represented as:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"HLC = (physicalTimeMillis, logicalCounter)\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"physicalTimeMillis"})}),": Wall clock in milliseconds (from the system clock)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"logicalCounter"})}),": A counter to preserve causality when physical time doesn't advance"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This allows timestamps to be ",(0,t.jsx)(n.strong,{children:"monotonically increasing"})," even under clock skew or rapid successive events."]}),"\n",(0,t.jsx)(n.h2,{id:"use-cases-in-kahuna",children:"Use Cases in Kahuna"}),"\n",(0,t.jsx)(n.h3,{id:"transaction-timestamps",children:"Transaction Timestamps"}),"\n",(0,t.jsx)(n.p,{children:"Each transaction in Kahuna is assigned a commit timestamp using the node\u2019s local HLC:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"On transaction start"}),": An HLC is assigned and carried through the transaction"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"On commit"}),": The final HLC timestamp is used as the ",(0,t.jsx)(n.strong,{children:"version"})," for all written keys"]}),"\n",(0,t.jsxs)(n.li,{children:["Kahuna ensures that timestamps respect causality: if transaction A commits before B, then ",(0,t.jsx)(n.code,{children:"HLC(A) < HLC(B)"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This guarantees ",(0,t.jsx)(n.strong,{children:"snapshot isolation"})," and enables ",(0,t.jsx)(n.strong,{children:"serializable execution"})," when required."]}),"\n",(0,t.jsx)(n.h3,{id:"multi-version-concurrency-control-mvcc",children:"Multi-Version Concurrency Control (MVCC)"}),"\n",(0,t.jsx)(n.p,{children:"Kahuna uses HLCs as version stamps for key/value records. Each key maintains:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "transactionId": { "physical": 1713351023980, "logical": 3 },\n  "key": "user:123",\n  "value": "..."  \n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["MVCC reads filter out versions that are ",(0,t.jsx)(n.strong,{children:"in the future"})," relative to the transaction's timestamp, or based on a snapshot HLC. This avoids phantom reads and preserves consistency across nodes."]}),"\n",(0,t.jsx)(n.h3,{id:"conflict-detection",children:"Conflict Detection"}),"\n",(0,t.jsx)(n.p,{children:"In distributed environments, concurrent writes to the same key can occur. Kahuna uses HLC to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Compare write timestamps"}),": If two writes target the same key, the write with the ",(0,t.jsx)(n.strong,{children:"higher HLC"})," wins"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Detect stale writes"}),": Any incoming write with ",(0,t.jsx)(n.code,{children:"HLC < current_version"})," is rejected as stale"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This ensures ",(0,t.jsx)(n.strong,{children:"last-write-wins semantics"}),", while still allowing clients to detect and resolve concurrent update scenarios explicitly if needed."]}),"\n",(0,t.jsx)(n.h3,{id:"locking-and-sequencing",children:"Locking and Sequencing"}),"\n",(0,t.jsx)(n.p,{children:"Locks and sequences are tagged with HLC timestamps:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Leases"}),": Each lease has an HLC to track the moment it was granted"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fencing tokens"}),": Include HLC components to uniquely order lock ownership transitions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sequences"}),": Issued in increasing HLC order to maintain monotonic guarantees across partitions"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This enables time-based expiration and fencing guarantees without relying on synchronized clocks."}),"\n",(0,t.jsx)(n.h3,{id:"cluster-wide-consistency-without-truetime",children:"Cluster-Wide Consistency Without TrueTime"}),"\n",(0,t.jsxs)(n.p,{children:["Instead of relying on GPS or atomic clocks like ",(0,t.jsx)(n.strong,{children:"TrueTime"}),", Kahuna nodes:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Advance their HLC state on each local or replicated write"}),"\n",(0,t.jsx)(n.li,{children:"Ensure that no HLC ever goes backward (even across restarts)"}),"\n",(0,t.jsxs)(n.li,{children:["May delay reads until a ",(0,t.jsx)(n.strong,{children:"safe time"})," if external consistency is requested (e.g., ",(0,t.jsx)(n.code,{children:"read-after-write"})," guarantees)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This means ",(0,t.jsx)(n.strong,{children:"external consistency"})," can be simulated by ",(0,t.jsx)(n.strong,{children:"waiting"})," until the system clock has moved past the latest known HLC timestamp."]}),"\n",(0,t.jsx)(n.h2,{id:"example-hlc-write-flow-in-kahuna",children:"Example: HLC Write Flow in Kahuna"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Client sends a write to node A."}),"\n",(0,t.jsx)(n.li,{children:"Node A assigns an HLC timestamp using its local clock."}),"\n",(0,t.jsx)(n.li,{children:"The write is replicated to other Raft followers."}),"\n",(0,t.jsx)(n.li,{children:"Each replica updates its local HLC state if the incoming HLC is higher."}),"\n",(0,t.jsx)(n.li,{children:"The key is stored as:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "transactionId": { "physical": 1713351023980, "logical": 3 },  \n  "key": "config/service/timeout",\n  "value": "500ms",  \n}\n'})}),"\n",(0,t.jsxs)(n.ol,{start:"6",children:["\n",(0,t.jsx)(n.li,{children:"Future writes to the same key must use a strictly greater HLC, ensuring a consistent order."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"design-advantages",children:"Design Advantages"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Benefit"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Causality preservation"})}),(0,t.jsx)(n.td,{children:"Prevents anomalies by enforcing happens-before relationships"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Clock skew tolerance"})}),(0,t.jsx)(n.td,{children:"HLC logic avoids dependence on perfect clock sync"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Unified time model"})}),(0,t.jsx)(n.td,{children:"Used for transactions, locks, sequences, and replication"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Conflict resolution"})}),(0,t.jsx)(n.td,{children:"Enables consistent behavior across concurrent writers"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Time-based operations"})}),(0,t.jsx)(n.td,{children:"TTLs, leases, and expirations are all HLC-based"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"TrueTime alternative"})}),(0,t.jsx)(n.td,{children:"Offers strong external consistency without external time APIs"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"hlc-timeline",children:"HLC Timeline"}),"\n",(0,t.jsx)("div",{style:{textAlign:"center"},children:(0,t.jsx)("img",{src:c,height:"350"})}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsxs)(n.p,{children:["HLCs are a core enabler of Kahuna's ",(0,t.jsx)(n.strong,{children:"distributed consistency model"}),". By embedding time into every operation while preserving logical correctness, HLC allows Kahuna to offer:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Strong consistency"}),"\n",(0,t.jsx)(n.li,{children:"Efficient MVCC"}),"\n",(0,t.jsx)(n.li,{children:"Reliable lock sequencing"}),"\n",(0,t.jsx)(n.li,{children:"Deterministic conflict resolution"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"\u2014 all while remaining independent of external clock guarantees or centralized coordination."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>l});var i=s(6540);const t={},r=i.createContext(t);function c(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);