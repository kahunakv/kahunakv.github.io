"use strict";(self.webpackChunkkahunakv_docs=self.webpackChunkkahunakv_docs||[]).push([[423],{7784:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"distributed-keyvalue-store/cas","title":"Compare-And-Swap (CAS)","description":"A Compare-And-Swap (CAS) operation is critical in a distributed key-value store like Kahuna because it ensures atomic updates and prevents race conditions in environments where multiple clients may try to modify the same key simultaneously. CAS is an atomic operation that:","source":"@site/docs/distributed-keyvalue-store/cas.md","sourceDirName":"distributed-keyvalue-store","slug":"/distributed-keyvalue-store/cas","permalink":"/docs/distributed-keyvalue-store/cas","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/distributed-keyvalue-store/cas.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Overview","permalink":"/docs/distributed-keyvalue-store"},"next":{"title":"Distributed Transactions","permalink":"/docs/distributed-keyvalue-store/transactions"}}');var i=t(4848),r=t(8453);const a={},o="Compare-And-Swap (CAS)",l={},c=[{value:"Examples",id:"examples",level:2},{value:"Distributed Queue Consumer Lock",id:"distributed-queue-consumer-lock",level:3},{value:"Feature Flag Update Control",id:"feature-flag-update-control",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"compare-and-swap-cas",children:"Compare-And-Swap (CAS)"})}),"\n",(0,i.jsx)(n.p,{children:"A Compare-And-Swap (CAS) operation is critical in a distributed key-value store like Kahuna because it ensures atomic updates and prevents race conditions in environments where multiple clients may try to modify the same key simultaneously. CAS is an atomic operation that:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Compares a key\u2019s current value (or version) against an expected value or revision"}),"\n",(0,i.jsx)(n.li,{children:"Only updates the key if the current value matches the expected value or revision"}),"\n",(0,i.jsx)(n.li,{children:"Fails safely if another process modified the key in the meantime."}),"\n"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Use Case"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"How CAS Helps"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Leader Election"})}),(0,i.jsx)(n.td,{children:"Ensures only one node becomes leader."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Distributed Locks"})}),(0,i.jsx)(n.td,{children:"Prevents multiple nodes from acquiring the same lock."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Configuration Updates"})}),(0,i.jsx)(n.td,{children:"Prevents conflicting writes to shared config values."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Rate Limiting"})}),(0,i.jsx)(n.td,{children:"Ensures atomic updates to request counters."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Concurrent Transactions"})}),(0,i.jsx)(n.td,{children:"Avoids lost updates when multiple clients modify the same key."})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Advantages of using CAS:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ensures atomic updates"})," in distributed stores."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Prevents race conditions"})," when multiple clients write to the same key."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Guarantees strong consistency"})," by checking versioning before updating."]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"It can be used in leader election, distributed locks, and state coordination."})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Prevents lost updates"})," and ensures correct data modifications."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(n.p,{children:"The client provides specialized methods to execute CAS operations based on the value or revision:"}),"\n",(0,i.jsx)(n.h3,{id:"distributed-queue-consumer-lock",children:"Distributed Queue Consumer Lock"}),"\n",(0,i.jsx)(n.p,{children:"Use Case: Multiple workers process tasks from a queue but each task should only be handled once"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'using Kahuna.Client;\n\npublic async Task HandleTask(KahunaClient client, string taskId)\n{\n    string keyName = "/locks/task/" + taskId;\n    string machineName = Environment.MachineName;\n\n    // Sets the initial value normally if it hasn\'t been assigned before\n    (bool success, long revision) = await client.SetKeyValue(\n        keyName, \n        machineName, \n        10000, \n        KeyValueFlags.SetIfNotExists\n    );\n\n    if (!success)\n    {\n        Console.WriteLine("Other node acquired the task");\n        return;\n    }\n    \n    // Process the task here\n    // ...\n\n    // Mark the task as completed if this node still hold the key\n    (success, revision) = await client.TryCompareValueAndSetKeyValue(keyName, "completed", machineName, 10000);\n\n    if (success)\n    {\n        Console.WriteLine("Marked as completed successfully");\n        return;\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"feature-flag-update-control",children:"Feature Flag Update Control"}),"\n",(0,i.jsx)(n.p,{children:"Use Case: Update a feature flag, but only if it hasn\u2019t changed since you last read it."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'using Kahuna.Client;\n\npublic async Task CheckFeatureFlag(KahunaClient client, string featureName)\n{\n    string featureKey = "/feature/" + featureName;    \n\n    // Obtains the current value of the feature flag\n    (byte[]? _, long revision) = await client.GetKeyValue(keyName);\n            \n    // ...\n\n    // Check if the flag was changed\n    (success, revision) = await client.TryCompareRevisionAndSetKeyValue(featureKey, "enabled", revision);\n\n    if (success)\n    {\n        Console.WriteLine("No one else changed the flag between our read and write.");\n        return;\n    }\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);