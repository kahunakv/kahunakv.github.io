"use strict";(self.webpackChunkkahunakv_docs=self.webpackChunkkahunakv_docs||[]).push([[5843],{1469:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>o,contentTitle:()=>a,default:()=>x,frontMatter:()=>d,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"distributed-keyvalue-store","title":"Distributed Key/Value Store","description":"A distributed key/value store is a type of database system designed to store, retrieve, and manage data across multiple nodes in a cluster or distributed environment. It follows a simple key-value data model, where keys are unique identifiers, and values are arbitrary byte stream associated data objects.","source":"@site/docs/distributed-keyvalue-store.md","sourceDirName":".","slug":"/distributed-keyvalue-store","permalink":"/docs/distributed-keyvalue-store","draft":false,"unlisted":false,"editUrl":"https://github.com/kahunakv/kahunakv.github.io/tree/main/docs/docs/distributed-keyvalue-store.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Fencing Tokens","permalink":"/docs/distributed-locks/fencing-tokens"},"next":{"title":"Compare-And-Swap (CAS)","permalink":"/docs/distributed-keyvalue-store/cas"}}');var r=s(4848),t=s(8453);const l=s.p+"assets/images/kahuna4-8d2c753219d601728d105c299240e3af.png",d={},a="Distributed Key/Value Store",o={},c=[{value:"Key Characteristics",id:"key-characteristics",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"Kahuna Distributed Store",id:"kahuna-distributed-store",level:2},{value:"Revisions",id:"revisions",level:2},{value:"API",id:"api",level:2},{value:"Set",id:"set",level:3},{value:"Compare-Value-And-Swap (CVAS)",id:"compare-value-and-swap-cvas",level:3},{value:"Compare-Revision-And-Swap (CRAS)",id:"compare-revision-and-swap-cras",level:3},{value:"Get",id:"get",level:3},{value:"Get Revision",id:"get-revision",level:3},{value:"Get By Prefix",id:"get-by-prefix",level:3},{value:"Scan By Prefix",id:"scan-by-prefix",level:3},{value:"Delete",id:"delete",level:3},{value:"Extend",id:"extend",level:3},{value:"Exists",id:"exists",level:3}];function h(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"distributed-keyvalue-store",children:"Distributed Key/Value Store"})}),"\n",(0,r.jsx)("div",{style:{textAlign:"center"},children:(0,r.jsx)("img",{src:l,height:"350"})}),"\n",(0,r.jsxs)(i.p,{children:["A ",(0,r.jsx)(i.strong,{children:"distributed key/value store"})," is a type of ",(0,r.jsx)(i.strong,{children:"database system"})," designed to store, retrieve, and manage data across multiple nodes in a cluster or distributed environment. It follows a simple ",(0,r.jsx)(i.strong,{children:"key-value data model"}),", where ",(0,r.jsx)(i.strong,{children:"keys"})," are unique identifiers, and ",(0,r.jsx)(i.strong,{children:"values"})," are arbitrary byte stream associated data objects."]}),"\n",(0,r.jsx)(i.h2,{id:"key-characteristics",children:"Key Characteristics"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Scalability"})," \u2013 The system distributes data across multiple machines, allowing it to scale horizontally as demand increases. If the nodes are multi-processor, Kahuna can process multiple requests in parallel."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Fault Tolerance"})," \u2013 By replicating data across multiple nodes, it ensures resilience against failures."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"High Availability"})," \u2013 Data is accessible even if some nodes go offline, minimizing downtime."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Strong Consistency"})," \u2013 Ensures reliable data integrity using the ",(0,r.jsx)(i.strong,{children:"Raft consensus protocol"}),"."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Low Latency"})," \u2013 Optimized for fast read/write operations, making it ideal for caching, real-time applications and distributed computing."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Distributed Transactions"})," \u2013 Supports multi-node transactions with ",(0,r.jsx)(i.strong,{children:"Multi-Version Concurrency Control (MVCC)"}),", ",(0,r.jsx)(i.strong,{children:"Pessimistic/Optimistic Locking"}),", and ",(0,r.jsx)(i.strong,{children:"Two-Phase Commit (2PC)"})," for consistency across distributed operations."]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Configuration Management"})," \u2013 Storing dynamic settings for applications (e.g., feature flags)."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Metadata Storage"})," \u2013 Keeping track of distributed system metadata (e.g., leader election in Raft)."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Session Management"})," \u2013 Storing user sessions across distributed servers."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Caching"})," \u2013 Speeding up data access by storing frequently used data."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Distributed Coordination"})," \u2013 Managing distributed locks and leader election."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Transactional Workloads"})," \u2013 Ensuring atomicity and consistency across distributed transactions."]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"kahuna-distributed-store",children:"Kahuna Distributed Store"}),"\n",(0,r.jsxs)(i.p,{children:["In the context of ",(0,r.jsx)(i.strong,{children:"Kahuna"}),", its ",(0,r.jsx)(i.strong,{children:"distributed key/value store"})," capability allows applications to store and retrieve data efficiently, ensuring ",(0,r.jsx)(i.strong,{children:"strong consistency, high availability, and low latency"}),". Additionally, ",(0,r.jsx)(i.strong,{children:"Kahuna supports distributed transactions"}),", enabling applications to execute ",(0,r.jsx)(i.strong,{children:"atomic, consistent, isolated, and durable (ACID) operations"})," across multiple nodes. This is achieved using:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Multi-Version Concurrency Control (MVCC)"})," \u2013 Allowing non-blocking reads and improved concurrency."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Pessimistic and Optimistic Locking"})," \u2013 Supporting different locking mechanisms to prevent conflicts in concurrent transactions."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Two-Phase Commit (2PC)"})," \u2013 Ensuring atomicity in distributed transactions across multiple nodes."]}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["These features make Kahuna a great solution for small transactional workloads requiring ",(0,r.jsx)(i.strong,{children:"data integrity, consistency, and high availability"}),"."]}),"\n",(0,r.jsx)(i.h2,{id:"revisions",children:"Revisions"}),"\n",(0,r.jsxs)(i.p,{children:["In Kahuna, a ",(0,r.jsx)(i.a,{href:"distributed-keyvalue-store/revisions",children:"revision"})," is a monotonic, ever-increasing number that represents the global order of modifications in the key-value store. Every time a change (write, delete, or transaction) occurs in Kahuna, the revision number increases, ensuring strong consistency and strict ordering of operations. Each revision is a 64-bit cluster-wide counter."]}),"\n",(0,r.jsx)(i.h2,{id:"api",children:"API"}),"\n",(0,r.jsx)(i.p,{children:"Kahuna provides an API for performing various operations on key/value pairs:"}),"\n",(0,r.jsx)(i.h3,{id:"set",children:"Set"}),"\n",(0,r.jsx)(i.p,{children:"Sets or overwrites key/value pairs. The behavior of the API is modified based on the provided flags, which determine whether the operation occurs depending on the key's existence, current value, or current revision."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-csharp",children:"(bool Set, long Revision) TrySet(string key, byte[] value, Flags flags, Consistency consistency);\n"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"key:"})," A unique identifier for the key/value pair."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"value:"})," The data object associated with the key."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"expiresMs:"})," The expiration time of the key in milliseconds."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"flags:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["If ",(0,r.jsx)(i.code,{children:"Flags.SetIfExists"})," is specified, the value is set only if the key already exists."]}),"\n",(0,r.jsxs)(i.li,{children:["If ",(0,r.jsx)(i.code,{children:"Flags.SetIfNotExists"})," is specified, the value is set only if the key does not exist."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"durability:"})," Defines whether the key durability is ",(0,r.jsx)(i.strong,{children:"Ephemeral"})," or ",(0,r.jsx)(i.strong,{children:"Persistent"}),"."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Returns:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Set:"})," ",(0,r.jsx)(i.code,{children:"true"})," if the key's value was modified."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Revision:"})," A global counter indicating how many times the key has been modified."]}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"compare-value-and-swap-cvas",children:"Compare-Value-And-Swap (CVAS)"}),"\n",(0,r.jsx)(i.p,{children:"Sets or overwrites key/value pairs, but only if the current value matches a specified comparison value."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-csharp",children:"(bool Set, long Revision) TryCompareValueAndSet(string key, byte[] value, byte[] compareValue, Durability durability);\n"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"key:"})," A unique identifier for the key/value pair."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"value:"})," The data object associated with the key."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"compareValue:"})," The value is changed only if the current value matches the provided one."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"expiresMs:"})," The expiration time of the key in milliseconds."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"durability:"})," Defines whether the key durability is ",(0,r.jsx)(i.strong,{children:"Ephemeral"})," or ",(0,r.jsx)(i.strong,{children:"Persistent"}),"."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Returns:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Set:"})," ",(0,r.jsx)(i.code,{children:"true"})," if the key's value was modified."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Revision:"})," A global counter indicating how many times the key has been modified."]}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"compare-revision-and-swap-cras",children:"Compare-Revision-And-Swap (CRAS)"}),"\n",(0,r.jsx)(i.p,{children:"Sets or overwrites key/value pairs, but only if the current revision matches a specified comparison revision."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-csharp",children:"(bool Set, long Revision) TryCompareRevisionAndSet(string key, byte[] value, long compareRevision, Durability durability);\n"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"key:"})," A unique identifier for the key/value pair."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"value:"})," The data object associated with the key."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"compareRevision:"})," The value is changed only if the current revision matches the provided one."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"expiresMs:"})," The expiration time of the key in milliseconds."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"durability:"})," Defines whether the key durability is ",(0,r.jsx)(i.strong,{children:"Ephemeral"})," or ",(0,r.jsx)(i.strong,{children:"Persistent"}),"."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Returns:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Set:"})," ",(0,r.jsx)(i.code,{children:"true"})," if the key's value was modified."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Revision:"})," A global counter indicating how many times the key has been modified."]}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"get",children:"Get"}),"\n",(0,r.jsxs)(i.p,{children:["Retrieves the value of a key along with its revision. If the key does not exist, the special value ",(0,r.jsx)(i.code,{children:"nil"})," is returned."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-csharp",children:"(bool Found, byte[] Value, long Revision) TryGet(string key, Durability durability);\n"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"key:"})," The key to be queried."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"durability:"})," Defines whether the key durability is ",(0,r.jsx)(i.strong,{children:"Ephemeral"})," or ",(0,r.jsx)(i.strong,{children:"Persistent"}),"."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Returns:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Found:"})," ",(0,r.jsx)(i.code,{children:"true"})," if the key exists."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Value:"})," The value associated with the key."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Revision:"})," A global counter indicating how many times the key has been modified."]}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"get-revision",children:"Get Revision"}),"\n",(0,r.jsxs)(i.p,{children:["Retrieves the value of a key at the specific revision. If the key/revision combination does not exist in the key/value store, the special value ",(0,r.jsx)(i.code,{children:"nil"})," is returned."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-csharp",children:"(bool Found, byte[] Value, long Revision) TryGet(string key, long revision, Durability durability);\n"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"key:"})," The key to be queried."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"revision:"})," The revision to be returned."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"durability:"})," Defines whether the key durability is ",(0,r.jsx)(i.strong,{children:"Ephemeral"})," or ",(0,r.jsx)(i.strong,{children:"Persistent"}),"."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Returns:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Found:"})," ",(0,r.jsx)(i.code,{children:"true"})," if the key exists."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Value:"})," The value associated with the key."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Revision:"})," The queried revision."]}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"get-by-prefix",children:"Get By Prefix"}),"\n",(0,r.jsx)(i.p,{children:"Retrieves the key/value pairs that share the same prefix. The key/value pairs are returned in a consistent way if a common bucket is passed as prefix."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-csharp",children:"(KeyValuePair[]) GetByPrefix(string prefix, Durability durability);\n"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"key:"})," The key to be queried."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"revision:"})," The revision to be returned."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"durability:"})," Defines whether the keys durability is ",(0,r.jsx)(i.strong,{children:"Ephemeral"})," or ",(0,r.jsx)(i.strong,{children:"Persistent"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Returns:"}),"\n",(0,r.jsx)(i.strong,{children:"KeyValuePair:"})]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Key:"})," The key found."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Value:"})," The value associated with the key."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Revision:"})," The current revision of the key."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Expires:"})," The unix timestamp in milliseconds when the key will expire."]}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"scan-by-prefix",children:"Scan By Prefix"}),"\n",(0,r.jsx)(i.p,{children:"Scan all nodes in the cluster searching for key/value pairs where the key start with the specified prefix. The key/value pairs data are taken from the moment\nthe node is visited. It can contain stale data. This API is slow because it scans all nodes and internal workers for keys."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-csharp",children:"(KeyValuePair[]) ScanByPrefix(string prefix, Durability durability);\n"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"key:"})," The key to be queried."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"revision:"})," The revision to be returned."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"durability:"})," Defines whether the keys durability is ",(0,r.jsx)(i.strong,{children:"Ephemeral"})," or ",(0,r.jsx)(i.strong,{children:"Persistent"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Returns:"}),"\n",(0,r.jsx)(i.strong,{children:"KeyValuePair:"})]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Key:"})," The key found."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Value:"})," The value associated with the key."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Revision:"})," The current revision of the key."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Expires:"})," The unix timestamp in milliseconds when the key will expire."]}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"delete",children:"Delete"}),"\n",(0,r.jsx)(i.p,{children:"Deletes a key and its associated value. Deleting a key does not remove the key history."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-csharp",children:"(bool Deleted, long Revision) TryDelete(string key, Durability durability);\n"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"key:"})," The key to be deleted."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"durability:"})," Defines whether the key durability is ",(0,r.jsx)(i.strong,{children:"Ephemeral"})," or ",(0,r.jsx)(i.strong,{children:"Persistent"}),"."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Returns:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Deleted:"})," ",(0,r.jsx)(i.code,{children:"true"})," if the key/value pair was deleted."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Revision:"})," The global counter indicating how many times the key was modified at the time of deletion. Deleting a key does ",(0,r.jsx)(i.strong,{children:"not"})," increment the revision counter."]}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"extend",children:"Extend"}),"\n",(0,r.jsx)(i.p,{children:"Extends a key timeout. The key will be deleted after the key expires. If the expiration is 0 the key will not be expired or removed."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-csharp",children:"(bool Extended, long Revision) TryExtend(string key, int expiresMs, Durability durability);\n"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"key:"})," The key to be extended."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"expiresMs:"})," The expiration time of the key in milliseconds."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"durability:"})," Defines whether the key durability is ",(0,r.jsx)(i.strong,{children:"Ephemeral"})," or ",(0,r.jsx)(i.strong,{children:"Persistent"}),"."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Returns:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Extended:"})," ",(0,r.jsx)(i.code,{children:"true"})," if the key/value pair was extended."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Revision:"})," The global counter indicating how many times the key was modified at the time of deletion. Extending the key does ",(0,r.jsx)(i.strong,{children:"not"})," increment the revision counter."]}),"\n"]}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h3,{id:"exists",children:"Exists"}),"\n",(0,r.jsx)(i.p,{children:"Returns if a key exists."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-csharp",children:"(bool Exists, long Revision) Exists(string key, Durability durability);\n"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"key:"})," The key to be checked if exists."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"durability:"})," Defines whether the key durability is ",(0,r.jsx)(i.strong,{children:"Ephemeral"})," or ",(0,r.jsx)(i.strong,{children:"Persistent"}),"."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Returns:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Exists:"})," ",(0,r.jsx)(i.code,{children:"true"})," if the key/value pair exists."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Revision:"})," The global counter indicating how many times the key was modified at the time of the query."]}),"\n"]})]})}function x(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,i,s)=>{s.d(i,{R:()=>l,x:()=>d});var n=s(6540);const r={},t=n.createContext(r);function l(e){const i=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function d(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),n.createElement(t.Provider,{value:i},e.children)}}}]);