"use strict";(self.webpackChunkkahunakv_docs=self.webpackChunkkahunakv_docs||[]).push([[386],{1007:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"distributed-locks","title":"Distributed Locks","description":"A distributed lock is a mechanism that ensures that a specific resource is accessed by only one node or process at a time in a distributed environment. This is crucial when:","source":"@site/docs/distributed-locks.md","sourceDirName":".","slug":"/distributed-locks","permalink":"/docs/distributed-locks","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/distributed-locks.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Getting Started","permalink":"/docs/getting-started"},"next":{"title":"Overview","permalink":"/docs/distributed-keyvalue-store"}}');var t=s(4848),r=s(8453);const l={sidebar_position:3},c="Distributed Locks",o={},a=[{value:"API",id:"api",level:3},{value:"Lock",id:"lock",level:4},{value:"Unlock",id:"unlock",level:4},{value:"Extend",id:"extend",level:4},{value:"Leases",id:"leases",level:3},{value:"Fencing Tokens",id:"fencing-tokens",level:3},{value:"Lock Acquisition:",id:"lock-acquisition",level:4},{value:"Using the Fencing Token:",id:"using-the-fencing-token",level:4},{value:"Handling Client Failures:",id:"handling-client-failures",level:4}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"distributed-locks",children:"Distributed Locks"})}),"\n",(0,t.jsx)(n.p,{children:"A distributed lock is a mechanism that ensures that a specific resource is accessed by only one node or process at a time in a distributed environment. This is crucial when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Preventing race conditions:"})," Ensuring that multiple processes do not modify shared resources simultaneously."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Coordinating tasks:"})," Managing access to shared databases, files, or services across different nodes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Maintaining data consistency:"})," Guaranteeing that concurrent operations do not result in inconsistent states."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By partitioning locks among nodes controlled by Raft Groups, Kahuna offers:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consistency:"})," Data is replicated to"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reliability:"})," Raft consensus ensures that partition data remains consistent even in the face of network failures."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Simplicity:"})," A straightforward API based on leases makes it easy to integrate distributed locking into your applications."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"api",children:"API"}),"\n",(0,t.jsx)(n.p,{children:"Kahuna exposes a simple API for acquiring and releasing locks. The main functions are:"}),"\n",(0,t.jsx)(n.h4,{id:"lock",children:"Lock"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"(bool Locked, long FencingToken) TryLock(string resource, string owner, int expiresMs, Consistency consistency);\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"resource:"})," The identifier for the resource you want to lock."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"owner:"})," A unique identifier for the lock, usually associated with the client or process requesting the lock."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"expiresMs:"})," The expiration time for the lock in milliseconds."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"consistency:"})," Linearizable (strong) or Ephemeral."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Locked:"})," ",(0,t.jsx)(n.code,{children:"true"})," if the lock was successfully acquired."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"FencingToken:"})," A global counter indicating the number of times the lock has been acquired."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"unlock",children:"Unlock"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"(bool Unlocked) Unlock(string resource, string owner);\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"resource:"})," The identifier for the resource to unlock."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"owner:"})," The unique identifier for the lock previously used to acquire the lock."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unlocked:"})," ",(0,t.jsx)(n.code,{children:"false"})," if the resource was successfully unlocked."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"extend",children:"Extend"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"(bool Extended, long FencingToken) Extend(string resource, string owner, int expiresMs);\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"resource:"})," The identifier for the resource you want to extend."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"owner:"})," A unique identifier for the lock, usually associated with the client or process requesting the lock. It must be the current owner of the lock."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"expiresMs:"})," The expiration time for the lock in milliseconds."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Extended:"})," ",(0,t.jsx)(n.code,{children:"true"})," if the lock was successfully extended."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"FencingToken:"})," A global counter indicating the number of times the lock has been acquired."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"leases",children:"Leases"}),"\n",(0,t.jsxs)(n.p,{children:["Distributed locks in Kahuna are based on the paper ",(0,t.jsx)(n.a,{href:"https://web.stanford.edu/class/cs240/readings/leases.pdf",children:(0,t.jsx)(n.em,{children:'"Leases: An Efficient\nFault-Tolerant Mechanism for Distributed File Cache Consistency"'})})," by Michael N. Nelson, Brent B. Welch, and John K. Ousterhout.\nIt introduced the concept of ",(0,t.jsx)(n.strong,{children:"leases"})," as a way to manage distributed locks efficiently.\nLeases act as time-bound locks that expire after a specified duration,\nproviding a balance between strong consistency and fault tolerance."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Automatic Lock Expiration"}),": Leases expire after a predefined time,\neliminating the need for manual lock release. This is particularly useful if a client holding a lock crashes or becomes unreachable, as the system can reclaim the resource once the lease expires."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"No Need for Explicit Unlock"}),": Despite Kahuna clients sent explicit unlocks, clients\ndon't need to explicitly release them, which reduces the complexity of\nhandling failures and network partitions."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reduced Lock Contention"}),": Since leases are time-bound, even if a client misbehaves or gets disconnected, other clients will eventually be able to acquire the lock after the lease expires."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Graceful Degradation"}),": In the event of partial failures (e.g., network partitions), the system can still make progress once the lease times out."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Do leases provide mutual exclusion? No, leases by themselves do not provide mutual exclusion."}),"\n",(0,t.jsx)(n.p,{children:"While Kahuna leases help in expiring keys and releasing locks if a client fails, they don\u2019t inherently protect against scenarios where:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A client pauses (e.g., due to a long GC pause or network partition) and later resumes, believing it still holds the lock, even though the lease has expired."}),"\n",(0,t.jsx)(n.li,{children:"This could lead to split-brain where two clients believe they own the same lock."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"fencing-tokens",children:"Fencing Tokens"}),"\n",(0,t.jsx)(n.p,{children:"A fencing token is a monotonically increasing number (e.g., version number) issued every time a lock is acquired.\nIt acts as a logical timestamp to resolve stale client operations."}),"\n",(0,t.jsx)(n.p,{children:"How Leases + Fencing Tokens can provide Strong Mutual Exclusion:"}),"\n",(0,t.jsx)(n.h4,{id:"lock-acquisition",children:"Lock Acquisition:"}),"\n",(0,t.jsx)(n.p,{children:"A client tries to acquire a lock by creating a key in Kahuna (e.g., my-lock-resource) with a lease.\nAlong with the key, Kahuna maintains a fencing token \u2014 typically an incrementing counter."}),"\n",(0,t.jsx)(n.h4,{id:"using-the-fencing-token",children:"Using the Fencing Token:"}),"\n",(0,t.jsx)(n.p,{children:"When a client successfully acquires the lock, it receives the fencing token.\nAll downstream services that the client interacts with must validate the fencing token.\nThese services should reject any operation with a stale fencing token (i.e., a token lower than the highest one they've seen)."}),"\n",(0,t.jsx)(n.h4,{id:"handling-client-failures",children:"Handling Client Failures:"}),"\n",(0,t.jsx)(n.p,{children:"If a client pauses or crashes and its lease expires, Kahuna deletes the lock key.\nAnother client can now acquire the lock with a new lease and gets a higher fencing token.\nEven if the first client resumes and tries to perform actions, downstream systems will reject its operations because its fencing token is outdated."}),"\n",(0,t.jsx)(n.p,{children:"Example Flow:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Client A acquires the lock with fencing token #5."}),"\n",(0,t.jsx)(n.li,{children:"Client A writes to a resource, passing #5."}),"\n",(0,t.jsx)(n.li,{children:"Client A experiences a network partition or pause."}),"\n",(0,t.jsx)(n.li,{children:"Kahuna lease expires, and Client B acquires the lock with fencing token #6."}),"\n",(0,t.jsx)(n.li,{children:"Client B writes to the same resource, passing #6."}),"\n",(0,t.jsx)(n.li,{children:"Client A comes back online and tries to write again with fencing token #5, but downstream systems reject it because they've already processed token #6."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>c});var i=s(6540);const t={},r=i.createContext(t);function l(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);