"use strict";(self.webpackChunkkahunakv_docs=self.webpackChunkkahunakv_docs||[]).push([[9954],{486:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"distributed-keyvalue-store/revisions","title":"Revisions","description":"In Kahuna, a revision is a monotonic version number that tracks when a key was last modified. Every time a key is updated or deleted, its revision increments, ensuring strong consistency and strict ordering. It acts as a logical timestamp to resolve stale client operations.","source":"@site/docs/distributed-keyvalue-store/revisions.md","sourceDirName":"distributed-keyvalue-store","slug":"/distributed-keyvalue-store/revisions","permalink":"/docs/distributed-keyvalue-store/revisions","draft":false,"unlisted":false,"editUrl":"https://github.com/kahunakv/kahunakv.github.io/tree/main/docs/docs/distributed-keyvalue-store/revisions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Compare-And-Swap (CAS)","permalink":"/docs/distributed-keyvalue-store/cas"},"next":{"title":"Key Distribution and Buckets","permalink":"/docs/distributed-keyvalue-store/buckets"}}');var r=n(4848),t=n(8453);const a={},o="Revisions",l={},d=[{value:"Understanding revisions",id:"understanding-revisions",level:2},{value:"Querying Previous Revisions",id:"querying-previous-revisions",level:2},{value:"Practical Uses of Retrieving Old Revisions",id:"practical-uses-of-retrieving-old-revisions",level:2},{value:"Summary",id:"summary",level:2}];function c(e){const s={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"revisions",children:"Revisions"})}),"\n",(0,r.jsxs)(s.p,{children:["In Kahuna, a ",(0,r.jsx)(s.code,{children:"revision"})," is a monotonic version number that tracks when a key was last modified. Every time a key is updated or deleted, its ",(0,r.jsx)(s.code,{children:"revision"})," increments, ensuring strong consistency and strict ordering. It acts as a logical timestamp to resolve stale client operations."]}),"\n",(0,r.jsx)(s.h2,{id:"understanding-revisions",children:"Understanding revisions"}),"\n",(0,r.jsxs)(s.p,{children:["Keys are always created at revision ",(0,r.jsx)(s.code,{children:"r0"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ruby",children:"set `example` 'value1'\nr0 set 17ms\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Modify the key and revision will change to ",(0,r.jsx)(s.code,{children:"r1"})," and then to ",(0,r.jsx)(s.code,{children:"r2"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ruby",children:"set `example` 'value2'\nr1 set 12ms\n\nset `example` 'value3'\nr2 set 9ms\n"})}),"\n",(0,r.jsx)(s.p,{children:"When querying a key, you can see its current revision. The revision does not change during read operations:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ruby",children:"get `example`\nr2 value3 10ms\n\nget `example`\nr2 value3 9ms\n"})}),"\n",(0,r.jsx)(s.h2,{id:"querying-previous-revisions",children:"Querying Previous Revisions"}),"\n",(0,r.jsx)(s.p,{children:"Kahuna works like a time machine, allowing you to query the value of a key at any particular point-in-time:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ruby",children:"get `example` at 0\nr0 value1 11ms\n\nget `example` at 1\nr1 value2 13ms\n"})}),"\n",(0,r.jsx)(s.p,{children:"This lets you inspect historical data, trace config or state changes historically, debug changes over time, investigate what value caused a bug or revert to stable known-good values."}),"\n",(0,r.jsx)(s.h2,{id:"practical-uses-of-retrieving-old-revisions",children:"Practical Uses of Retrieving Old Revisions"}),"\n",(0,r.jsx)(s.p,{children:"While many systems only care about the latest value, Kahuna's ability to retrieve old revisions opens up some powerful, practical use cases\u2014especially in distributed systems, debugging, auditing and observability:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Audit Trails and Change History:"})," Kahuna stores each change at a new revision, so you can inspect historical values. Useful for debugging, compliance, or postmortem analysis. With revisions we can see how a config flag looked at a specific point in time. Helps trace misconfigurations or unauthorized changes."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Debugging State Changes Over Time"}),": Understand how and why a system entered a bad state. Distributed systems can be hard to debug after the fact and Retrieving old revisions helps you reconstruct the timeline of state changes. It's useful when investigating failures that occurred hours or days ago."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Safe Rollbacks of Configuration or State"}),": Roll back to a previous known-good configuration. If a new config breaks the system, you can pull a previous value and restore it. Provides a quick and clean rollback mechanism."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Data Versioning for CI/CD or Experiments"}),": Compare previous and current values during deploys or A/B tests. You can track how configs or feature flags evolved over time. Useful for debugging failed deployments or verifying that changes had intended effects."]}),"\n"]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Kahuna"})," supports two types of durability: ",(0,r.jsx)(s.code,{children:"ephemeral"}),", which uses only the volatile memory (RAM) of the leader node where the key/value is stored, and ",(0,r.jsx)(s.code,{children:"persistent"}),", which uses durable disk-based storage. In case of memory pressure, ephemeral keys may be evicted if they haven\u2019t been accessed recently. In the case of ephemeral storage, the server stores a limited number of recent revisions. If you need to store all revisions of a key, you should use persistent storage. Learn more in the ",(0,r.jsx)(s.a,{href:"../architecture/durability-levels",children:"supported durabilities"})," section"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Revision tracks when a key was last modified."}),"\n",(0,r.jsx)(s.li,{children:"It updates on every write but stays the same for reads."}),"\n",(0,r.jsx)(s.li,{children:"Used in leader election, distributed locks and race condition prevention."}),"\n",(0,r.jsx)(s.li,{children:"Essential for Compare-And-Swap (CAS) operations."}),"\n"]})]})}function u(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>o});var i=n(6540);const r={},t=i.createContext(r);function a(e){const s=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(t.Provider,{value:s},e.children)}}}]);