"use strict";(self.webpackChunkkahunakv_docs=self.webpackChunkkahunakv_docs||[]).push([[3415],{1147:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/kahuna6-96619c8185cec986d639081f4926c4da.png"},6552:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"distributed-sequencer","title":"Distributed Sequencer","description":"Distributed systems are hard because there\u2019s no shared memory, clocks are not perfectly synchronized, and messages can arrive out of order. A distributed sequencer provides a way to enforce order despite all that chaos.","source":"@site/docs/distributed-sequencer.md","sourceDirName":".","slug":"/distributed-sequencer","permalink":"/docs/distributed-sequencer","draft":false,"unlisted":false,"editUrl":"https://github.com/kahunakv/kahunakv.github.io/tree/main/docs/docs/distributed-sequencer.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Transactions","permalink":"/docs/distributed-keyvalue-store/transactions"},"next":{"title":"Scripts : Overview","permalink":"/docs/scripts"}}');var r=s(4848),i=s(8453),a=s(1147);const o={},c="Distributed Sequencer",d={},l=[{value:"What It Enables",id:"what-it-enables",level:2},{value:"Key Features:",id:"key-features",level:2}];function u(e){const n={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"distributed-sequencer",children:"Distributed Sequencer"})}),"\n",(0,r.jsx)("div",{style:{textAlign:"center"},children:(0,r.jsx)("img",{src:a.A,height:"350"})}),"\n",(0,r.jsx)(n.p,{children:"Distributed systems are hard because there\u2019s no shared memory, clocks are not perfectly synchronized, and messages can arrive out of order. A distributed sequencer provides a way to enforce order despite all that chaos."}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"Kahuna's distributed sequencer"})," generates monotonically increasing, globally ordered sequence of identifiers (often called sequence numbers, version numbers, or timestamps). Its job is to ensure that operations across multiple nodes can be totally ordered even though they happen concurrently on different machines."]}),"\n",(0,r.jsx)(n.p,{children:"It can be used to answer the question: What happened first? By assigning each operation a unique, increasing number (or timestamp), you can impose order on a system that is otherwise full of race conditions, concurrent updates, and network delays."}),"\n",(0,r.jsx)(n.h2,{id:"what-it-enables",children:"What It Enables"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"External Global Sequences"}),": In an environment with multiple hybrid systems, Kahuna serves as a central point for obtaining global sequences: invoice numbers, NFT numbering, assigning the next number in an artifact or mobile build machine, unique IDs for customers in a sharded database, and more."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Total Ordering:"})," Ensures that every node sees changes in the same order. Crucial for logs, ledgers, replicated state machines."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Conflict Resolution:"})," Helps detect and resolve write-write or read-write conflicts. For example, last-writer-wins or fencing token semantics."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Replication & Recovery"}),": Ensures all replicas apply updates in the same sequence. Makes log-based recovery deterministic and safe."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Leader Election / Locking"}),": Fencing tokens generated by a sequencer prevent stale leaders from performing dangerous operations."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"key-features",children:"Key Features:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Strong Consistency & Durability:"})," Built with a focus on reliability, every generated sequence maintains strong consistency and durability. This guarantees that even in distributed environments, no sequence is ever duplicated or lost."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Efficient Load Distribution:"})," Leveraging Raft Groups, the system assigns sequences to different nodes. This strategy not only maximizes compute power across the cluster but also enhances performance and fault tolerance."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Seamless Integration:"})," The distributed sequencer is designed to be easily integrated into various applications, making it an ideal solution for systems requiring reliable, high-volume sequence generation."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In summary, a ",(0,r.jsx)(n.strong,{children:"distributed sequencer"})," is what keeps order in a world full of distributed chaos. It\u2019s a foundational building block that makes strong consistency, safe concurrency and ordered replication possible."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(6540);const r={},i=t.createContext(r);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);