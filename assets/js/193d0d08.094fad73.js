"use strict";(self.webpackChunkkahunakv_docs=self.webpackChunkkahunakv_docs||[]).push([[1980],{8453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>o});var s=n(6540);const r={},t=s.createContext(r);function a(e){const i=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:i},e.children)}},9921:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"architecture/durability-levels","title":"Durability Levels","description":"Persistent Durability","source":"@site/docs/architecture/durability-levels.md","sourceDirName":"architecture","slug":"/architecture/durability-levels","permalink":"/docs/architecture/durability-levels","draft":false,"unlisted":false,"editUrl":"https://github.com/kahunakv/kahunakv.github.io/tree/main/docs/docs/architecture/durability-levels.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Raft in Kahuna: Consensus and High Availability System","permalink":"/docs/architecture/raft"},"next":{"title":"Rate Limiting","permalink":"/docs/recipes/rate-limiting"}}');var r=n(4848),t=n(8453);const a={},o="Durability Levels",l={},d=[{value:"Persistent Durability",id:"persistent-durability",level:2},{value:"Ephemeral Durability",id:"ephemeral-durability",level:2},{value:"Cache Entries",id:"cache-entries",level:2},{value:"Summary of Durability Modes: Advantages and Disadvantages",id:"summary-of-durability-modes-advantages-and-disadvantages",level:2},{value:"Persistent Durability",id:"persistent-durability-1",level:3},{value:"Ephemeral Durability",id:"ephemeral-durability-1",level:3}];function c(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"durability-levels",children:"Durability Levels"})}),"\n",(0,r.jsx)(i.h2,{id:"persistent-durability",children:"Persistent Durability"}),"\n",(0,r.jsx)(i.p,{children:"Kahuna prioritizes the durable storage of data (locks, keys, and sequences) on disk across multiple nodes in the cluster. This design ensures high availability and recovery in case of node crashes or failures. Each time a write operation occurs, the following process is executed:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Storing the Key-Value Pair:"}),"  Suppose we want to store a key named ",(0,r.jsx)(i.code,{children:"my-config"})," with the value ",(0,r.jsx)(i.code,{children:"'my-value'"}),"."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Partition Determination:"}),"  A consistent hash is computed for ",(0,r.jsx)(i.code,{children:"my-config"})," to determine its partition. For example, ",(0,r.jsxs)(i.strong,{children:["CH(",(0,r.jsx)(i.code,{children:"my-config"}),") = 42"]}),"."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Leader Identification:"}),"  The node designated as the leader for the Raft group (or partition) 42 is identified. Note that the leader node may differ from the node that initially accepts the transaction, so the request is redirected to the leader node."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Proposal and Consensus:"}),"  The leader node then proposes the write operation (",(0,r.jsx)(i.code,{children:"set my-config 'my-value'"}),") to the other nodes in the cluster. The proposal must be accepted by the follower nodes if no conflicts arise."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Temporary Write:"}),"  After receiving confirmation from a majority of the follower nodes, the leader temporarily writes the new key-value pair to its own disk."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Commit Phase:"}),"  The leader then instructs the followers to persist the key-value pair on their disks."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Visibility:"}),"  Finally, the leader makes the change visible, so that ",(0,r.jsx)(i.code,{children:"my-config"})," now holds the value ",(0,r.jsx)(i.code,{children:"'my-value'"}),". If the read is part of a transaction, an additional MVCC (Multi-Version Concurrency Control) entry is created to provide snapshot isolation and ensure consistent reads within the transaction."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Concurrency Control:"}),"  During this process, any reader clients attempting to access the key or other clients trying to modify it are blocked until the operation is fully completed and confirmed."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"This orchestration ensures that data is durably replicated across multiple nodes, maintaining consistency for all read and write operations."}),"\n",(0,r.jsx)(i.p,{children:"For read operations, the following process is executed:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Read Request:"}),"  Suppose we want to read the key ",(0,r.jsx)(i.code,{children:"my-config"}),"."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Partition Determination:"}),"  A consistent hash is computed for ",(0,r.jsx)(i.code,{children:"my-config"})," to determine its partition. For example, ",(0,r.jsxs)(i.strong,{children:["CH(",(0,r.jsx)(i.code,{children:"my-config"}),") = 42"]}),"."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Leader Identification:"}),"  The node designated as the leader for the Raft group (or partition) 42 is identified. If the node receiving the request is not the leader, the request is redirected accordingly."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Retrieval from Durable Storage:"}),"  The leader reads the latest version of the key from its durable storage. A cache entry is created in memory to avoid repeated disk access for subsequent operations."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Returning the Value:"}),"  The key\u2019s value is returned to the client."]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"ephemeral-durability",children:"Ephemeral Durability"}),"\n",(0,r.jsx)(i.p,{children:"Not all operations require long-term durability. In scenarios where keys, locks, and sequences are short-lived, Kahuna offers Ephemeral durability, which limits storage to the volatile memory (RAM) of the leader server for the partition."}),"\n",(0,r.jsx)(i.p,{children:"For ephemeral keys, each time a write operation occurs, the following process is executed:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Storing the Ephemeral Key-Value Pair:"}),"  Suppose we want to store an ephemeral key named ",(0,r.jsx)(i.code,{children:"my-config"})," with the value ",(0,r.jsx)(i.code,{children:"'my-value'"}),"."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Partition Determination:"}),"  A consistent hash is computed for ",(0,r.jsx)(i.code,{children:"my-config"})," to determine its partition. For example, ",(0,r.jsxs)(i.strong,{children:["CH(",(0,r.jsx)(i.code,{children:"my-config"}),") = 42"]}),"."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Leader Identification:"}),"  The node designated as the leader for the Raft group (or partition) 42 is identified. Similar to persistent durability, if the initial node is not the leader, the request is redirected."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"In-Memory Cache Handling:"}),"  The leader creates or retrieves the in-memory cache entry for the key ",(0,r.jsx)(i.code,{children:"my-config"})," and applies the change."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Visibility:"}),"  The updated value is made visible immediately, so that ",(0,r.jsx)(i.code,{children:"my-config"})," now holds the value ",(0,r.jsx)(i.code,{children:"'my-value'"}),". If the read is part of a transaction, an additional MVCC (Multi-Version Concurrency Control) entry is created to provide snapshot isolation and ensure consistent reads within the transaction."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Concurrency Control:"}),"  As with persistent operations, any reader or modifying client is blocked until the operation is fully completed and confirmed."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"This process ensures that all read and write operations maintain consistency even under concurrent access."}),"\n",(0,r.jsx)(i.h2,{id:"cache-entries",children:"Cache Entries"}),"\n",(0,r.jsxs)(i.p,{children:["Both ",(0,r.jsx)(i.strong,{children:"Ephemeral"})," and ",(0,r.jsx)(i.strong,{children:"Persistent"})," durability modes maintain an in-memory cache entry to accelerate read operations. These cache entries allow for thousands of reads per second, regardless of whether the key is persisted to disk. When memory capacity is reached, cache entries may be evicted based on an LRU (Least Recently Used) algorithm."]}),"\n",(0,r.jsx)(i.p,{children:"Key eviction occurs based on the following criteria:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Expired keys."}),"\n",(0,r.jsx)(i.li,{children:"Keys that have not been recently used, as determined by a configurable time window."}),"\n",(0,r.jsx)(i.li,{children:"A sample of keys, with the persistent key's on-disk representation remaining intact."}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"The eviction algorithm is executed independently for each partition, so that memory can be freed concurrently without impacting incoming read or write operations."}),"\n",(0,r.jsx)(i.h2,{id:"summary-of-durability-modes-advantages-and-disadvantages",children:"Summary of Durability Modes: Advantages and Disadvantages"}),"\n",(0,r.jsx)(i.h3,{id:"persistent-durability-1",children:"Persistent Durability"}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Advantages:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"High Availability and Resilience:"}),"  Data is stored on disk across multiple nodes, ensuring recovery in the event of node crashes or failures."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Consistency:"}),"  The use of replication and consensus mechanisms (via Raft) ensures that all read and write operations remain consistent."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Disadvantages:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Increased Latency:"}),"  Writing to disk and coordinating with multiple nodes introduces higher latency, which may impact performance."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Resource Intensive:"}),"  The replication and consensus processes require additional computational and storage resources."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Blocking Operations:"}),"  Read and Write operations are blocked until the write operations achieve quorum in the cluster, which can delay processing under heavy load."]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"ephemeral-durability-1",children:"Ephemeral Durability"}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Advantages:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Speed and Low Latency:"}),"  Operations are performed in memory, offering faster read and write responses."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Lower Resource Overhead:"}),"  By avoiding disk writes, system resource demands and replication overhead are minimized."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Efficiency for Short-Lived Data:"}),"  Ideal for use cases where data does not need long-term storage such as caches, short-lived locks, sessions, etc."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Disadvantages:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Lack of Persistence:"}),"  Data is volatile; in the event of a node failure, data stored only in memory is lost."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Limited Use Cases:"}),"  Best suited for temporary data such as caches, short-lived locks, sessions, etc, making it less appropriate for scenarios requiring long-term durability."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Potential Data Inconsistency on Failures:"}),"  With data not being stored to disk, recovery mechanisms may be limited during unexpected shutdowns or crashes."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"This balanced overview helps in choosing the right durability mode based on the specific operational needs and performance considerations of your use case."})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);