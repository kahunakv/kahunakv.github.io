"use strict";(self.webpackChunkkahunakv_docs=self.webpackChunkkahunakv_docs||[]).push([[8947],{1345:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"distributed-keyvalue-store/transactions","title":"Distributed Transactions","description":"Kahuna orchestrates distributed transactions by combining multi-version concurrency control (MVCC), a two-phase commit protocol and the Raft consensus algorithm to ensure consistency and high availability across a distributed key\u2013value store.","source":"@site/docs/distributed-keyvalue-store/transactions.md","sourceDirName":"distributed-keyvalue-store","slug":"/distributed-keyvalue-store/transactions","permalink":"/docs/distributed-keyvalue-store/transactions","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/distributed-keyvalue-store/transactions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Compare-And-Swap (CAS)","permalink":"/docs/distributed-keyvalue-store/cas"},"next":{"title":"Distributed Sequencer","permalink":"/docs/distributed-sequencer"}}');var r=t(4848),i=t(8453);const a={},o="Distributed Transactions",c={},l=[{value:"Key Components and Mechanisms",id:"key-components-and-mechanisms",level:3},{value:"Putting It All Together",id:"putting-it-all-together",level:3},{value:"What is Two-Phase Commit (2PC)?",id:"what-is-two-phase-commit-2pc",level:2},{value:"<strong>How 2PC Works in Kahuna:</strong>",id:"how-2pc-works-in-kahuna",level:3},{value:"<strong>Phase 1: Prepare (Pre-Commit)</strong>",id:"phase-1-prepare-pre-commit",level:4},{value:"<strong>Phase 2: Commit or Rollback</strong>",id:"phase-2-commit-or-rollback",level:4}];function d(e){const n={br:"br",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"distributed-transactions",children:"Distributed Transactions"})}),"\n",(0,r.jsx)(n.p,{children:"Kahuna orchestrates distributed transactions by combining multi-version concurrency control (MVCC), a two-phase commit protocol and the Raft consensus algorithm to ensure consistency and high availability across a distributed key\u2013value store."}),"\n",(0,r.jsx)(n.h3,{id:"key-components-and-mechanisms",children:"Key Components and Mechanisms"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Multi-Version Concurrency Control (MVCC):"}),(0,r.jsx)(n.br,{}),"\n","Kahuna uses MVCC to maintain multiple versions of data items. This allows transactions to read a consistent snapshot of the data without interfering with concurrent writes, ensuring isolation."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Two-Phase Commit (2PC) Protocol:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Prewrite Phase:"})," When a transaction starts, Kahuna's transaction coordinator selects a unique timestamp for the transaction. All writes are first \u201cprewritten.\u201d In this phase, locks are set on the involved keys and tentative data versions are written. This ensures that the transaction can later be committed atomically."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Commit Phase:"})," Once all prewrites succeed, the coordinator commits the transaction by first committing the key on the leaders and then informing other nodes to commit their corresponding replicas. If any node reports an issue during prewrite, the transaction is rolled back to maintain atomicity."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Raft Consensus for Replication and Fault Tolerance:"}),(0,r.jsx)(n.br,{}),"\n","Each Kahuna node is part of a Raft group that replicates data across several nodes. This means that even if some nodes fail, the transaction\u2019s state and data changes can be preserved across replicas. Raft ensures that all nodes agree on the order of operations, which is crucial for maintaining a consistent distributed state."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Handling Concurrency and Failures:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lock Management:"})," Locks on keys prevent conflicting operations, ensuring that only one transaction can modify a given data item at a time."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rollback Mechanisms:"})," In case a transaction cannot proceed (e.g., due to conflicts or node failures), Kahuna has mechanisms to clean up by rolling back any prewritten changes, thereby ensuring the system remains in a consistent state."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"putting-it-all-together",children:"Putting It All Together"}),"\n",(0,r.jsx)(n.p,{children:"When a client initiates a distributed transaction in Kahuna, it follows these steps:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The transaction begins by obtaining a timestamp (often provided by Kahuna node that accepts the request)."}),"\n",(0,r.jsx)(n.li,{children:"As the transaction executes, it reads from a consistent snapshot provided by MVCC."}),"\n",(0,r.jsx)(n.li,{children:"For writes, the coordinator performs a two-phase commit: first prewriting the changes with locks, then committing these changes across all involved nodes."}),"\n",(0,r.jsx)(n.li,{children:"The Raft protocol ensures that even when nodes are distributed across a network, all replicas agree on the operations being performed, preserving the durability and consistency of the transaction."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"what-is-two-phase-commit-2pc",children:"What is Two-Phase Commit (2PC)?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"2PC"})," is a distributed transaction protocol that ensures ",(0,r.jsx)(n.strong,{children:"atomicity across multiple independent nodes."})]}),"\n",(0,r.jsx)(n.h3,{id:"how-2pc-works-in-kahuna",children:(0,r.jsx)(n.strong,{children:"How 2PC Works in Kahuna:"})}),"\n",(0,r.jsx)(n.h4,{id:"phase-1-prepare-pre-commit",children:(0,r.jsx)(n.strong,{children:"Phase 1: Prepare (Pre-Commit)"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The node that receives the transaction is assigned as ",(0,r.jsx)(n.strong,{children:"transaction coordinator"}),". It sends a ",(0,r.jsx)(n.strong,{children:"prepare request"})," to all participating nodes."]}),"\n",(0,r.jsxs)(n.li,{children:["Each Kahuna node ",(0,r.jsx)(n.strong,{children:"locks the resources"})," (e.g., temporary key with a lease)."]}),"\n",(0,r.jsxs)(n.li,{children:["If all nodes agree, they respond ",(0,r.jsx)(n.strong,{children:'"Ready to Commit"'}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"phase-2-commit-or-rollback",children:(0,r.jsx)(n.strong,{children:"Phase 2: Commit or Rollback"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If all nodes respond ",(0,r.jsx)(n.strong,{children:"successfully"}),", the coordinator sends a ",(0,r.jsx)(n.strong,{children:"commit request"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.strong,{children:"any cluster fails"}),", the coordinator sends a ",(0,r.jsx)(n.strong,{children:"rollback request"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This ensures either ALL updates succeed or NONE happen."}),"\n",(0,r.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);